{"version":3,"file":"sunburst.js","sources":["../../src/component/sunburst.js"],"sourcesContent":["/**\n * Sunburst component\n *\n * This component renders a sunburst diagram, which is kind of like a layered pie chart. There is an\n * inner ring of values, which are total values for some large category. Each of these categories can\n * be broken down into smaller categories, which are shown in another layer around the inner ring. If these\n * categories can in turn be broken down into smaller ones, you can add yet another layer. The result\n * is a hierarchical display with the level of aggregation getting finer and finer as you get further\n * from the center of the chart.\n *\n * This component can accept either:\n * 1. Pre-processed flat sunburst data (backwards compatibility)\n * 2. Raw hierarchical data from prepareHierarchyData() (recommended)\n *\n * When using raw hierarchical data, the component will automatically apply the partition layout\n * and flatten the data internally.\n *\n * @property {Function} angleScale              Scale function for the angle of the segments of the sunburst chart. The domain\n *                                              should usually be [0, 1] and the range [0, 2 * PI]. These are used as defaults.\n * @property {Function} radiusScale             Scale function for the radius of segments. Can be configured using values returned from\n *                                              sszvis.layout.sunburst.computeLayout. See the examples for how the scale setup works.\n * @property {Number} centerRadius              The radius of the center of the chart. Can be configured with sszvis.layout.sunburst.computeLayout.\n * @property {Function} fill                    Function that returns the fill color for the segments in the center of the chart. Note that this will only be\n *                                              called on the centermost segments. The segments which are subcategories of these center segments\n *                                              will have their fill determined recursively, by lightening the color of its parent segment.\n * @property {Color, Function} stroke           The stroke color of the segments. Defaults to white.\n *\n * @return {sszvis.component}\n */\n\nimport { arc, hsl, interpolate, partition, scaleLinear, select } from \"d3\";\nimport tooltipAnchor from \"../annotation/tooltipAnchor.js\";\nimport { component } from \"../d3-component.js\";\nimport * as logger from \"../logger.js\";\nimport { defaultTransition } from \"../transition.js\";\n\nconst TWO_PI = 2 * Math.PI;\n\nexport default function () {\n  return component()\n    .prop(\"angleScale\")\n    .angleScale(scaleLinear().range([0, 2 * Math.PI]))\n    .prop(\"radiusScale\")\n    .prop(\"centerRadius\")\n    .prop(\"fill\")\n    .prop(\"stroke\")\n    .stroke(\"white\")\n    .render(function (inputData) {\n      const selection = select(this);\n      const props = selection.props();\n\n      // NOTE: Determine if we have raw hierarchical data or pre-computed sunburst data\n      // @deprecated in v3.4.0\n      let data;\n\n      if (Array.isArray(inputData)) {\n        // Already computed sunburst data (backwards compatibility)\n        data = inputData;\n      } else {\n        partition()(inputData);\n        function flatten(node) {\n          return Array.prototype.concat.apply([node], (node.children || []).map(flatten));\n        }\n        data = flatten(inputData).filter((d) => d.data._tag !== \"root\");\n      }\n\n      // Accepts a sunburst node and returns a d3.hsl color for that node (sometimes operates recursively)\n      function getColorRecursive(node) {\n        // Center node (if the data were prepared using sszvis.prepareHierarchyData)\n        if (node.data._tag === \"root\") {\n          return \"transparent\";\n        } else if (!node.parent) {\n          // Accounts for incorrectly formatted data which hasn't gone through sszvis.prepareHierarchyData\n          logger.warn(\n            \"Data passed to sszvis.component.sunburst does not have the expected tree structure. You should prepare it using sszvis.prepareHierarchyData\"\n          );\n          return hsl(props.fill(node.data.key));\n        } else if (node.parent.data._tag === \"root\") {\n          // Use the color scale\n          return hsl(props.fill(node.data.key));\n        } else {\n          // Recurse up the tree and adjust the lightness value\n          const pColor = getColorRecursive(node.parent);\n          pColor.l *= 1.15;\n          return pColor;\n        }\n      }\n\n      const startAngle = function (d) {\n        return Math.max(0, Math.min(TWO_PI, props.angleScale(d.x0)));\n      };\n      const endAngle = function (d) {\n        return Math.max(0, Math.min(TWO_PI, props.angleScale(d.x1)));\n      };\n      const innerRadius = function (d) {\n        return props.centerRadius + Math.max(0, props.radiusScale(d.y0));\n      };\n      const outerRadius = function (d) {\n        return props.centerRadius + Math.max(0, props.radiusScale(d.y1));\n      };\n\n      const arcGen = arc()\n        .startAngle(startAngle)\n        .endAngle(endAngle)\n        .innerRadius(innerRadius)\n        .outerRadius(outerRadius);\n\n      for (const d of data) {\n        // _x and _dx are the destination values for the transition.\n        // We set these to the computed x and dx.\n        d._x0 = d.x0;\n        d._x1 = d.x1;\n      }\n\n      const arcs = selection\n        .selectAll(\".sszvis-sunburst-arc\")\n        .each((d, i) => {\n          if (data[i]) {\n            // x and dx are the current/transitioning values\n            // We set these here, in case any datums already exist which have values set\n            data[i].x0 = d.x0;\n            data[i].x1 = d.x1;\n            // The transition tweens from x and dx to _x and _dx\n          }\n        })\n        .data(data)\n        .join(\"path\")\n        .attr(\"class\", \"sszvis-sunburst-arc\");\n\n      arcs.attr(\"stroke\", props.stroke).attr(\"fill\", getColorRecursive);\n\n      arcs.transition(defaultTransition()).attrTween(\"d\", (d) => {\n        const x0Interp = interpolate(d.x0, d._x0);\n        const x1Interp = interpolate(d.x1, d._x1);\n        return function (t) {\n          d.x0 = x0Interp(t);\n          d.x1 = x1Interp(t);\n          return arcGen(d);\n        };\n      });\n\n      // Add tooltip anchors\n      const arcTooltipAnchor = tooltipAnchor().position((d) => {\n        const startA = startAngle(d);\n        const endA = endAngle(d);\n        const a = startA + Math.abs(endA - startA) / 2 - Math.PI / 2;\n        const r = (innerRadius(d) + outerRadius(d)) / 2;\n        return [Math.cos(a) * r, Math.sin(a) * r];\n      });\n\n      selection.call(arcTooltipAnchor);\n    });\n}\n"],"names":["TWO_PI","Math","PI","component","prop","angleScale","scaleLinear","range","stroke","render","inputData","selection","select","props","data","Array","isArray","partition","flatten","node","prototype","concat","apply","children","map","filter","d","_tag","getColorRecursive","parent","logger","hsl","fill","key","pColor","l","startAngle","max","min","x0","endAngle","x1","innerRadius","centerRadius","radiusScale","y0","outerRadius","y1","arcGen","arc","_x0","_x1","arcs","selectAll","each","i","join","attr","transition","defaultTransition","attrTween","x0Interp","interpolate","x1Interp","t","arcTooltipAnchor","tooltipAnchor","position","startA","endA","a","abs","r","cos","sin","call"],"mappings":"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"}