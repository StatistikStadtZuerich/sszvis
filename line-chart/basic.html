<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title>Line Chart | Basic</title>
  </head>
  <body style="margin: 0; padding: 0">
    <link href="/sszvis.css" rel="stylesheet" />
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script src="/sszvis.js"></script>

    <div id="sszvis-chart"></div>

    <script>
      var EXTERNAL_CONFIG = {
        data: "data/ML_2Categories_Quarterly.csv",
        id: "#sszvis-chart",
        fallback: "fallback.png",
      };
    </script>

    <script data-catalog-project-expose="script.js">
      (function (d3, sszvis, config) {
        "use strict";

        function parseRow(d) {
          return {
            xValue: sszvis.parseDate(d["Datum"]),
            yValue: sszvis.parseNumber(d["Anzahl"]),
            category: d["Kategorie"],
          };
        }

        function xLabelFormat(d) {
          return d === 0 ? null : sszvis.formatYear(d);
        }

        function yLabelFormat(d) {
          return d === 0 ? null : sszvis.formatNumber(d);
        }

        function xValues(data, accessor) {
          return d3.extent(data, accessor);
        }

        function mkXScale() {
          return d3.scaleTime();
        }

        function mkXAxis(ticks, selection, xScale, accessor) {
          // Add the highlighted data as additional ticks to the xScale
          let xTickValues = ticks ? xScale.ticks(ticks) : xScale.ticks();
          xTickValues = [...xTickValues, ...selection.map(accessor)];
          xTickValues = xTickValues.filter(
            (v, i) => xTickValues.map(String).indexOf(String(v)) === i,
          );
          return sszvis.axisX.time().tickValues(xTickValues);
        }

        function closestDatum(data, accessor, datum) {
          const i = d3.bisector(accessor).left(data, datum, 1);
          const d0 = data[i - 1];
          const d1 = data[i] || d0;
          return datum - accessor(d0) > accessor(d1) - datum ? d1 : d0;
        }

        // Configuration
        // -----------------------------------------------

        const queryProps = sszvis
          .responsiveProps()
          .prop("rulerLabel", {
            _: () =>
              sszvis
                .modularTextSVG()
                .bold(sszvis.compose(yLabelFormat, yAcc))
                .plain((d) => (cAcc(d) == null ? "" : cAcc(d))),
          })
          .prop("xLabel", {
            _: "",
          })
          .prop("yLabel", {
            _: "",
          })
          .prop("ticks", {
            _: 5,
          });

        const xAcc = sszvis.prop("xValue");
        const yAcc = sszvis.prop("yValue");
        const cAcc = sszvis.prop("category");

        sszvis.app({
          fallback: {
            element: config.id,
            src: config.fallback,
          },

          // Init
          // -----------------------------------------------
          init: (state) =>
            d3.csv(config.data, parseRow).then((data) => {
              state.data = data;
              state.lineData = sszvis
                .cascade()
                .arrayBy(cAcc, d3.ascending)
                .apply(data);
              state.xValues = xValues(data, xAcc);
              state.categories = sszvis.set(data, cAcc);
              state.maxY = d3.max(data, yAcc);
              state.selection = [];
              return (dispatch) => dispatch("resetDate");
            }),

          // Actions
          // -----------------------------------------------
          actions: {
            resetDate(state) {
              // Find the most recent date in the data and set it as the selected date
              const mostRecentDate = d3.max(state.data, xAcc);
              return (dispatch) => {
                dispatch("changeDate", mostRecentDate);
              };
            },

            changeDate(state, e, inputDate) {
              // Find the date of the datum closest to the input date
              const closestDate = xAcc(
                closestDatum(state.data, xAcc, inputDate),
              );
              // Find all data that have the same date as the closest datum
              const closestData = state.lineData.map((linePoints) =>
                // For each line pick the first datum that matches
                sszvis.find(
                  (d) => xAcc(d).toString() === closestDate.toString(),
                  linePoints,
                ),
              );
              // Make sure that the selection has a value to display
              state.selection = closestData.filter(
                sszvis.compose(sszvis.not(isNaN), yAcc),
              );
            },
          },

          // Render
          // -----------------------------------------------
          render(state, actions) {
            const props = queryProps(sszvis.measureDimensions(config.id));

            const legendLayout = sszvis.colorLegendLayout(
              {
                axisLabels: state.xValues.map(xLabelFormat),
                legendLabels: state.categories,
              },
              config.id,
            );

            const cScale = legendLayout.scale;
            const colorLegend = legendLayout.legend;

            const bounds = sszvis.bounds(
              {
                top:
                  typeof props.yLabel === "string" && props.yLabel.length > 0
                    ? 30
                    : 10,
                bottom: legendLayout.bottomPadding,
              },
              config.id,
            );

            // Scales
            const xScale = mkXScale();

            xScale.domain(state.xValues).range([0, bounds.innerWidth]);

            const yScale = d3
              .scaleLinear()
              .domain([0, state.maxY])
              .range([bounds.innerHeight, 0]);

            // Layers
            const highlightLayer = sszvis
              .annotationRuler()
              .top(0)
              .bottom(bounds.innerHeight)
              .x(sszvis.compose(xScale, xAcc))
              .y(sszvis.compose(yScale, yAcc))
              .label(props.rulerLabel)
              .flip((d) => xScale(xAcc(d)) >= bounds.innerWidth / 2)
              .color(sszvis.compose(cScale, cAcc));

            const chartLayer = sszvis
              .createSvgLayer(config.id, bounds)
              .datum(state.lineData);

            // Components
            const line = sszvis
              .line()
              .x(sszvis.compose(xScale, xAcc))
              .y(sszvis.compose(yScale, yAcc))
              // Access the first data point of the line to decide on the stroke color
              .stroke(sszvis.compose(cScale, cAcc, sszvis.first));

            const xAxis = mkXAxis(props.ticks, state.selection, xScale, xAcc);

            xAxis
              .title(props.xLabel)
              .scale(xScale)
              .orient("bottom")
              .tickFormat(xLabelFormat)
              .highlightTick(isSelected)
              .alignOuterLabels(true);

            const yAxis = sszvis
              .axisY()
              .scale(yScale)
              .orient("right")
              .tickFormat(yLabelFormat)
              .contour(true)
              .title(props.yLabel)
              .dyTitle(-20);

            // Rendering
            chartLayer.selectGroup("line").call(line);

            chartLayer
              .selectGroup("xAxis")
              .attr("transform", sszvis.translateString(0, bounds.innerHeight))
              .call(xAxis);

            chartLayer.selectGroup("yAxis").call(yAxis);

            if (showLegend(state.categories)) {
              chartLayer
                .selectGroup("colorLegend")
                .attr(
                  "transform",
                  sszvis.translateString(
                    0,
                    bounds.innerHeight + legendLayout.axisLabelPadding,
                  ),
                )
                .call(colorLegend);
            }

            chartLayer
              .selectGroup("highlight")
              .datum(state.selection)
              .call(highlightLayer);

            // Interaction
            const interactionLayer = sszvis
              .move()
              .xScale(xScale)
              .yScale(yScale)
              .on("move", actions.changeDate)
              .on("end", actions.resetDate);

            chartLayer.selectGroup("interaction").call(interactionLayer);
          },
        });

        // Helper functions
        // -----------------------------------------------

        function showLegend(categories) {
          return (
            categories != null && categories[0] != null && categories[0] !== ""
          );
        }

        function isSelected(state) {
          return (d) =>
            sszvis.contains(state.selection.map(xAcc).map(String), String(d));
        }
      })(d3, sszvis, EXTERNAL_CONFIG);
    </script>
  </body>
</html>
