{"version":3,"file":"sunburst.js","sources":["../../src/layout/sunburst.js"],"sourcesContent":["/**\n * @module sszvis/layout/sunburst\n *\n * Helper functions for transforming your data to match the format required by the sunburst chart.\n */\n\nimport { hierarchy, max, min, partition, rollup } from \"d3\";\n\nimport * as fn from \"../fn.js\";\n\nfunction unwrapNested(roll) {\n  return Array.from(roll, ([key, values]) => ({\n    key,\n    values: values.size > 0 ? unwrapNested(values) : undefined,\n    value: values.size > 0 ? undefined : values,\n  }));\n}\n\nlet sortFn = () => 0;\n\n/**\n * sszvis.layout.sunburst.prepareData\n *\n * Creates a data preparation layout, with an API that works similarly to d3's configurable layouts.\n *\n * @property {Array} calculate      Accepts an array of data, and applies this layout to that data. Returns the formatted dataset,\n *                                  ready to be used as data for the sunburst component.\n * @property {Function} layer       Accepts a function, which should be a key function, used to create a layer for the data.\n *                                  The key function is applied to each datum, and the return value groups that datum within a\n *                                  layer of the sunburst chart. The exact behavior depends on the order in which layers are specified.\n *                                  The first specified layer will be the innermost one of the sunburst, with subsequent layers adding\n *                                  around the sunburst. Data are grouped according to the first layer, then the second layer, then the third, etc.\n *                                  This uses d3.nest under the hood, and applys the key function as a d3.nest().key, so it works like that.\n * @property {Function} value       The function which retrieves the value of each datum. This is required in order to calculate the size of\n *                                  the ring segment for each datum.\n * @property {Function} sort        Provide a sorting function for sibling nodes of the sunburst. The d3.partition layout probably uses a\n *                                  javascript object internally for some bookkeeping. At the moment, not all browsers handle key ordering in\n *                                  objects similarly. This sorting function is used to sort the output values of the d3.partition layout, according\n *                                  to user wishes. It receives two node values (which are created by d3), which should have at least a \"key\" property\n *                                  (corresponding to the layer key), and a \"value\" property (corresponding to the value amount of the slice).\n *                                  Otherwise, it behaves like a normal javascript array sorting function. The default value attempts to preserve the\n *                                  existing sort order of the data.\n *\n * @return {Function}               The layout function. Can be called directly or you can use '.calculate(dataset)'.\n */\nexport const prepareData = () => {\n  const layers = [];\n  let valueAcc = fn.identity;\n  // Sibling nodes of the partition layout are sorted according to this sort function.\n  // The default value for this component tries to preserve the order of the input data.\n  // However, input data order preservation is not guaranteed, because of an implementation\n  // detail of d3.partition, probably having to do with the way that each browser can\n  // implement its own key ordering for javascript objects.\n\n  function main(data) {\n    const nested = unwrapNested(rollup(data, fn.first, ...layers));\n\n    const root = hierarchy({ isSunburstRoot: true, values: nested }, fn.prop(\"values\"))\n      .sort(sortFn)\n      .sum((x) => (x.value ? valueAcc(x.value) : 0));\n\n    partition()(root);\n\n    function flatten(node) {\n      return Array.prototype.concat.apply([node], (node.children || []).map(flatten));\n    }\n\n    // Remove the root element from the data (but it still exists in memory so long as the data is alive)\n    return flatten(root).filter((d) => !d.data.isSunburstRoot);\n  }\n\n  main.calculate = (data) => main(data);\n\n  main.layer = (keyFunc) => {\n    layers.push(keyFunc);\n    return main;\n  };\n\n  main.value = (accfn) => {\n    valueAcc = accfn;\n    return main;\n  };\n\n  main.sort = (sortFunc) => {\n    sortFn = sortFunc;\n    return main;\n  };\n\n  return main;\n};\n\nexport const MAX_SUNBURST_RING_WIDTH = 60;\nconst MAX_RW = MAX_SUNBURST_RING_WIDTH;\n\nexport const MIN_SUNBURST_RING_WIDTH = 10;\nconst MIN_RW = MIN_SUNBURST_RING_WIDTH;\n\n/**\n * sszvis.layout.sunburst.computeLayout\n *\n * Computes layout parameters for good visual display of the sunburst chart.\n *\n * @param  {Number} numLayers          The number of layers in the sunburst chart.\n * @param  {Number} chartWidth         The total width available for displaying the sunburst chart.\n * @return {Object}                    Some parameters for the sunburst chart:\n *       @property {Number} centerRadius      The central radius of the chart (used by the sunburst component)\n *       @property {Number} numLayers         The number of layers in the chart (used by the sunburst component)\n *       @property {Number} ringWidth         The width of a single ring in the chart (used by the sunburst component)\n */\nexport const computeLayout = (numLayers, chartWidth) => {\n  // Diameter of the center circle is one-third the width\n  const halfWidth = chartWidth / 2;\n  const centerRadius = halfWidth / 3;\n  const ringWidth = Math.max(MIN_RW, Math.min(MAX_RW, (halfWidth - centerRadius) / numLayers));\n\n  return {\n    centerRadius,\n    numLayers,\n    ringWidth,\n  };\n};\n\n/**\n * sszvis.layout.sunburst.getRadiusExtent\n * @param  {Array} formattedData      An array of data to inspect for the extent of the radius scale\n *\n * @return {Array}                    The minimum and maximum radius values (in d3's partition layout's terms). Use this as\n *                                    The domain of the radius scale you use to configure the sunburst chart. This is a convenience\n *                                    function which abstracts away the way d3 stores positions within the partition layout used\n *                                    by the sunburst chart.\n */\nexport const getRadiusExtent = (formattedData) => [\n  min(formattedData, (d) => d.y0),\n  max(formattedData, (d) => d.y1),\n];\n"],"names":["unwrapNested","roll","Array","from","_ref","key","values","size","undefined","value","sortFn","prepareData","layers","valueAcc","fn","main","data","nested","rollup","root","hierarchy","isSunburstRoot","sort","sum","x","partition","flatten","node","prototype","concat","apply","children","map","filter","d","calculate","layer","keyFunc","push","accfn","sortFunc","MAX_SUNBURST_RING_WIDTH","MAX_RW","MIN_SUNBURST_RING_WIDTH","MIN_RW","computeLayout","numLayers","chartWidth","halfWidth","centerRadius","ringWidth","Math","max","min","getRadiusExtent","formattedData","y0","y1"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;AAMA,SAASA,YAAYA,CAACC,IAAI,EAAE;AAC1B,EAAA,OAAOC,KAAK,CAACC,IAAI,CAACF,IAAI,EAAEG,IAAA,IAAA;AAAA,IAAA,IAAC,CAACC,GAAG,EAAEC,MAAM,CAAC,GAAAF,IAAA;IAAA,OAAM;MAC1CC,GAAG;AACHC,MAAAA,MAAM,EAAEA,MAAM,CAACC,IAAI,GAAG,CAAC,GAAGP,YAAY,CAACM,MAAM,CAAC,GAAGE,SAAS;MAC1DC,KAAK,EAAEH,MAAM,CAACC,IAAI,GAAG,CAAC,GAAGC,SAAS,GAAGF;KACtC;AAAA,EAAA,CAAC,CAAC;AACL;AAEA,IAAII,MAAM,GAAGA,MAAM,CAAC;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,WAAW,GAAGA,MAAM;EAC/B,MAAMC,MAAM,GAAG,EAAE;AACjB,EAAA,IAAIC,QAAQ,GAAGC,QAAW;AAC1B;AACA;AACA;AACA;AACA;;EAEA,SAASC,IAAIA,CAACC,IAAI,EAAE;AAClB,IAAA,MAAMC,MAAM,GAAGjB,YAAY,CAACkB,MAAM,CAACF,IAAI,EAAEF,KAAQ,EAAE,GAAGF,MAAM,CAAC,CAAC;IAE9D,MAAMO,IAAI,GAAGC,SAAS,CAAC;AAAEC,MAAAA,cAAc,EAAE,IAAI;AAAEf,MAAAA,MAAM,EAAEW;AAAO,KAAC,EAAEH,IAAO,CAAC,QAAQ,CAAC,CAAC,CAChFQ,IAAI,CAACZ,MAAM,CAAC,CACZa,GAAG,CAAEC,CAAC,IAAMA,CAAC,CAACf,KAAK,GAAGI,QAAQ,CAACW,CAAC,CAACf,KAAK,CAAC,GAAG,CAAE,CAAC;AAEhDgB,IAAAA,SAAS,EAAE,CAACN,IAAI,CAAC;IAEjB,SAASO,OAAOA,CAACC,IAAI,EAAE;MACrB,OAAOzB,KAAK,CAAC0B,SAAS,CAACC,MAAM,CAACC,KAAK,CAAC,CAACH,IAAI,CAAC,EAAE,CAACA,IAAI,CAACI,QAAQ,IAAI,EAAE,EAAEC,GAAG,CAACN,OAAO,CAAC,CAAC;AACjF,IAAA;;AAEA;AACA,IAAA,OAAOA,OAAO,CAACP,IAAI,CAAC,CAACc,MAAM,CAAEC,CAAC,IAAK,CAACA,CAAC,CAAClB,IAAI,CAACK,cAAc,CAAC;AAC5D,EAAA;EAEAN,IAAI,CAACoB,SAAS,GAAInB,IAAI,IAAKD,IAAI,CAACC,IAAI,CAAC;AAErCD,EAAAA,IAAI,CAACqB,KAAK,GAAIC,OAAO,IAAK;AACxBzB,IAAAA,MAAM,CAAC0B,IAAI,CAACD,OAAO,CAAC;AACpB,IAAA,OAAOtB,IAAI;EACb,CAAC;AAEDA,EAAAA,IAAI,CAACN,KAAK,GAAI8B,KAAK,IAAK;AACtB1B,IAAAA,QAAQ,GAAG0B,KAAK;AAChB,IAAA,OAAOxB,IAAI;EACb,CAAC;AAEDA,EAAAA,IAAI,CAACO,IAAI,GAAIkB,QAAQ,IAAK;AACxB9B,IAAAA,MAAM,GAAG8B,QAAQ;AACjB,IAAA,OAAOzB,IAAI;EACb,CAAC;AAED,EAAA,OAAOA,IAAI;AACb;AAEO,MAAM0B,uBAAuB,GAAG;AACvC,MAAMC,MAAM,GAAGD,uBAAuB;AAE/B,MAAME,uBAAuB,GAAG;AACvC,MAAMC,MAAM,GAAGD,uBAAuB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACaE,aAAa,GAAGA,CAACC,SAAS,EAAEC,UAAU,KAAK;AACtD;AACA,EAAA,MAAMC,SAAS,GAAGD,UAAU,GAAG,CAAC;AAChC,EAAA,MAAME,YAAY,GAAGD,SAAS,GAAG,CAAC;EAClC,MAAME,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACR,MAAM,EAAEO,IAAI,CAACE,GAAG,CAACX,MAAM,EAAE,CAACM,SAAS,GAAGC,YAAY,IAAIH,SAAS,CAAC,CAAC;EAE5F,OAAO;IACLG,YAAY;IACZH,SAAS;AACTI,IAAAA;GACD;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMI,eAAe,GAAIC,aAAa,IAAK,CAChDF,GAAG,CAACE,aAAa,EAAGrB,CAAC,IAAKA,CAAC,CAACsB,EAAE,CAAC,EAC/BJ,GAAG,CAACG,aAAa,EAAGrB,CAAC,IAAKA,CAAC,CAACuB,EAAE,CAAC;;;;"}