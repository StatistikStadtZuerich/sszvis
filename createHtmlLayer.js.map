{"version":3,"file":"createHtmlLayer.js","sources":["../src/createHtmlLayer.js"],"sourcesContent":["/**\n * Factory that returns an HTML element appended to the given target selector,\n * ensuring that it is only created once, even when run again.\n *\n * Note on the 'key' property of the optional metadata object:\n *\n * The key argument is present so that we can have multiple layers of html content in the same container.\n * For example, let's imagine you want one html div under an svg, then an svg layer, then another div over the svg.\n * The reason we need a key for these layers is that the render function in all the example code is designed to be\n * idempotent - calling it multiple times with the same arguments leaves the app in the same state. Therefore, all\n * the functions within render also need to be idempotent. A straightforward implementation of \"createHtmlLayer\" would\n * return an existing layer if present, or create one and return it if it wasn't present. This prevents createHtmlLayer\n * from making a new html element every time it's called. In turn, that means that you can call render many times and\n * always expect the same result (idempotence). But it also means that if you call it multiple times within the same\n * render function, you don't get multiple html layers. So then you can't have one under the svg and one over.\n *\n * The key argument solves this problem. It says, \"look for a div in the container which has the given key, and return\n * it if present. Otherwise, create one with that key and return it. This means that if you call createHtmlLayer\n * multiple times with the same key, only one element will be created, and you'll get it back on subsequent calls.\n * But if you call it multiple times with different keys, you'll get multiple different elements. So, when you do:\n *\n * createHtmlLayer(..., ..., { key: 'A' })\n * createSvgLayer(...)\n * createHtmlLayer(..., ..., { key: 'B' })\n *\n * Then you'll have the div-svg-div sandwich, but that sequence of function calls is still idempotent.\n * Note: createSvgLayer accepts an optional metadata object, with an optional key property, which works the same way.\n *\n * @module sszvis/createHtmlLayer\n *\n * @param {string|d3.selection} selector    CSS selector string which is used to grab the container object for the created layer\n * @param {d3.bounds} [bounds]              A bounds object which provides the dimensions and offset for the created layer\n * @param {object} metadata                 Metadata for this layer. Currently the only used option is:\n *   @property {string} key                 Used as a unique key for this layer. If you pass different values\n *                                          of key to this function, the app will create and return different layers\n *                                          for inserting HTML content. If you pass the same value (including undefined),\n *                                          you will always get back the same DOM element. For example, this is useful for\n *                                          adding an HTML layer under an SVG, and then adding one over the SVG.\n *                                          See the binned raster map for an example of using this effectively.\n *\n * @returns {d3.selection}\n */\n\nimport { select } from \"d3\";\nimport { bounds as mkBounds } from \"./bounds.js\";\nimport * as fn from \"./fn.js\";\n\nexport function createHtmlLayer(selector, bounds, metadata) {\n  bounds || (bounds = mkBounds());\n  metadata || (metadata = {});\n\n  const key = metadata.key || \"default\";\n\n  const elementDataKey = \"data-sszvis-html-\" + key;\n\n  const root = fn.isSelection(selector) ? selector : select(selector);\n  root.classed(\"sszvis-outer-container\", true);\n\n  return root\n    .selectAll(\"[data-sszvis-html-layer][\" + elementDataKey + \"]\")\n    .data([0])\n    .join(\"div\")\n    .classed(\"sszvis-html-layer\", true)\n    .attr(\"data-sszvis-html-layer\", \"\")\n    .attr(elementDataKey, \"\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", bounds.padding.left + \"px\")\n    .style(\"top\", bounds.padding.top + \"px\");\n}\n"],"names":["createHtmlLayer","selector","bounds","metadata","mkBounds","key","elementDataKey","root","fn","select","classed","selectAll","data","join","attr","style","padding","left","top"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMO,SAASA,eAAeA,CAACC,QAAQ,EAAEC,QAAM,EAAEC,QAAQ,EAAE;AAC1DD,EAAAA,QAAM,KAAKA,QAAM,GAAGE,MAAQ,EAAE,CAAC;AAC/BD,EAAAA,QAAQ,KAAKA,QAAQ,GAAG,EAAE,CAAC;AAE3B,EAAA,MAAME,GAAG,GAAGF,QAAQ,CAACE,GAAG,IAAI,SAAS;AAErC,EAAA,MAAMC,cAAc,GAAG,mBAAmB,GAAGD,GAAG;AAEhD,EAAA,MAAME,IAAI,GAAGC,WAAc,CAACP,QAAQ,CAAC,GAAGA,QAAQ,GAAGQ,MAAM,CAACR,QAAQ,CAAC;AACnEM,EAAAA,IAAI,CAACG,OAAO,CAAC,wBAAwB,EAAE,IAAI,CAAC;AAE5C,EAAA,OAAOH,IAAI,CACRI,SAAS,CAAC,2BAA2B,GAAGL,cAAc,GAAG,GAAG,CAAC,CAC7DM,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CACTC,IAAI,CAAC,KAAK,CAAC,CACXH,OAAO,CAAC,mBAAmB,EAAE,IAAI,CAAC,CAClCI,IAAI,CAAC,wBAAwB,EAAE,EAAE,CAAC,CAClCA,IAAI,CAACR,cAAc,EAAE,EAAE,CAAC,CACxBS,KAAK,CAAC,UAAU,EAAE,UAAU,CAAC,CAC7BA,KAAK,CAAC,MAAM,EAAEb,QAAM,CAACc,OAAO,CAACC,IAAI,GAAG,IAAI,CAAC,CACzCF,KAAK,CAAC,KAAK,EAAEb,QAAM,CAACc,OAAO,CAACE,GAAG,GAAG,IAAI,CAAC;AAC5C;;;;"}