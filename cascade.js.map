{"version":3,"file":"cascade.js","sources":["../src/cascade.js"],"sourcesContent":["/**\n * Cascade module\n *\n * @module sszvis/cascade\n *\n * sszvis.cascade is a module that can be useful for creating nested data structures.\n * It can be used in similar ways to d3.nest, but should not be conflated with d3.nest,\n * since it provides different behavior.\n *\n * The cascade class is not a data structure. Rather, it is used to create a data structue\n * generator. An instance of the cascade class should be configured to specify the desired\n * characteristics of the resulting data structure, and then applied to a flat array of\n * objects in order to generate the data structure.\n *\n * Fundamental to the cascade class is the concept of \"groupBy\", which is an operation that\n * transforms a flat array of data into a nested data structure. It does this by\n * passing each value in the flat array through an accessor function, and \"groping\" those\n * elements based on the return value of that function. Every element in the resulting groups\n * will have produced the same value when passed into the accessor function.\n *\n * For example, if a flat data set contains a number of elements, and some have a value \"city = Zurich\",\n * while others have a value \"city = Basel\", performing a groupBy operation on this data set\n * and passing a predicate function which returns the value of the \"city\" property of these objects\n * will form the objects into groups where all objects in one group have \"city = Zurich\", and all objects\n * in the other group have \"city = Basel\".\n *\n * The Cascade module abstracts the concept of \"groupBy\" on multiple levels, and provides the option\n * to arrange the resultant groups in different ways.\n *\n * There are two options for the form of the resulting groups. (This is where sszvis.cascade\n * diverges in behavior from d3.nest, which offers two options, but they must be the same through\n * the entire data structure):\n *\n * In one version, the groups are formed into a plain Javascript object with key -> value pairs. The keys are\n * the set of results from the grouping function. (In our example, the keys would be \"Zurich\" and \"Basel\")\n * In this implementation, the values are each arrays of elements which share the value of the key function.\n * However, these objects may be nested arbitrarily deep. If multiple layers of objects are specified, then the\n * values will themselves be objects with key -> value pairs, and so on. The final layer of objects will have\n * arrays for values, where each element in the arrays is a data object which shares values for all of the specified\n * key properties with the other objects in its array.\n *\n * Alternatively, the input array of objects can be grouped into an array of groups, where the groups\n * contain data values which all share the same value for a certain key property. These, too, can be nested.\n * The sub-groups may be formed as arrays, where each element in the next level is grouped\n * according to the same principle, but with a different key function. Alternatively, the groups may be\n * objects, grouped according to the principle described in the first version. It is up to the user of the\n * class to specify the extent and nature of this nesting. If an array of groups is the last level of the cascade,\n * its values will be arrays of data values.\n *\n * At the base of the cascade, regardless of the types of the levels, will be arrays of data objects. These arrays\n * can also be thought of as containing the leaves of the tree structure.\n *\n * Instances of this class are configured using three methods: \"objectBy\", \"arrayBy\", and \"sort\". They are used by\n * calling the \"apply\" method, passing a flat array of data objects. The first three methods return the instance\n * to enable method chaining, while \"apply\" returns the nested data structure.\n *\n * @method objectBy         Takes as argument a predicate function which is called on each element in an input array. The\n *                          return values of this function are used to create an object with key -> value pairs, where the keys\n *                          are the results of the calls to the predicate function and the values are a further layer of the cascade.\n * @method arrayBy          Takes as argument a predicate function which is called on each element in an input array. The\n *                          return values of this function are used to create an array, where each element of the array\n *                          is a further layer of the cascade. arrayBy also takes an optional second parameter, which specifys\n *                          a sorting function. If provided, groups in the resulting array will be sorted by passing the key values\n *                          of the groups through the sorting function. For example, if an alphabetical sort function is passed\n *                          as the second parameter to an arrayBy call in the example above, the resulting array will be sorted\n *                          such that the first group is the one with \"city = Basel\" and the second group is the one with \"city = Zurich\".\n *                          The sort function should take the usual form of a function passed to Array.prototype.sort().\n * @method sort             This method specifies a sort function for the very last layer of the cascade, which is always arrays of data objects.\n *                          the sort function passed to this method should accept data objects as values.\n *\n * @returns                 An instance of sszvis.cascade\n */\n\nfunction groupBy(data, keyFunc) {\n  const group = {};\n  let key;\n  for (let i = 0, l = data.length, value; i < l; ++i) {\n    value = data[i];\n    key = keyFunc(value);\n    if (group[key]) {\n      group[key].push(value);\n    } else {\n      group[key] = [value];\n    }\n  }\n  return group;\n}\n\nfunction groupEach(data, func) {\n  for (const prop in data) {\n    func(data[prop], prop);\n  }\n}\n\nfunction arrEach(arr, func) {\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    func(arr[i], i);\n  }\n}\n\nexport function cascade() {\n  const _cascade = {},\n    keys = [],\n    sorts = [];\n  let valuesSort;\n\n  function make(data, depth) {\n    if (depth >= keys.length) {\n      if (valuesSort) data.sort(valuesSort);\n      return data;\n    }\n\n    const sorter = sorts[depth];\n    const key = keys[depth++];\n    const grouped = groupBy(data, key.func);\n\n    if (key.type === \"obj\") {\n      const obj = {};\n      groupEach(grouped, (value, k) => {\n        obj[k] = make(value, depth);\n      });\n      return obj;\n    } else if (key.type === \"arr\") {\n      const arr = [];\n      if (sorter) {\n        const groupKeys = Object.keys(grouped).sort(sorter);\n        arrEach(groupKeys, (k) => {\n          arr.push(make(grouped[k], depth));\n        });\n      } else {\n        groupEach(grouped, (value) => {\n          arr.push(make(value, depth));\n        });\n      }\n      return arr;\n    }\n  }\n\n  _cascade.apply = function (data) {\n    return make(data, 0);\n  };\n\n  _cascade.objectBy = function (d) {\n    keys.push({\n      type: \"obj\",\n      func: d,\n    });\n    return _cascade;\n  };\n\n  _cascade.arrayBy = function (d, sorter) {\n    keys.push({\n      type: \"arr\",\n      func: d,\n    });\n    if (sorter) sorts[keys.length - 1] = sorter;\n    return _cascade;\n  };\n\n  _cascade.sort = function (d) {\n    valuesSort = d;\n    return _cascade;\n  };\n\n  return _cascade;\n}\n"],"names":["groupBy","data","keyFunc","group","key","i","l","length","value","push","groupEach","func","prop","arrEach","arr","cascade","_cascade","keys","sorts","valuesSort","make","depth","sort","sorter","grouped","type","obj","k","groupKeys","Object","apply","objectBy","d","arrayBy"],"mappings":"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"}