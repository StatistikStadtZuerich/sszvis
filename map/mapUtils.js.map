{"version":3,"file":"mapUtils.js","sources":["../../src/map/mapUtils.js"],"sourcesContent":["/*\n * A collection of utilities used by the map modules\n *\n * @module sszvis/map/utils\n */\n\nimport { geoMercator, geoPath, geoCentroid } from \"d3\";\nimport { memoize } from \"../fn.js\";\n\nexport const STADT_KREISE_KEY = \"zurichStadtKreise\";\nexport const STATISTISCHE_QUARTIERE_KEY = \"zurichStatistischeQuartiere\";\nexport const STATISTISCHE_ZONEN_KEY = \"zurichStatistischeZonen\";\nexport const WAHL_KREISE_KEY = \"zurichWahlKreise\";\nexport const AGGLOMERATION_2012_KEY = \"zurichAgglomeration2012\";\nexport const SWITZERLAND_KEY = \"switzerland\";\n\n/**\n * swissMapProjection\n *\n * A function for creating d3 projection functions, customized for the dimensions of the map you need.\n * Because this projection generator involves calculating the boundary of the features that will be\n * projected, the result of these calculations is cached internally. Hence the featureBoundsCacheKey.\n * You don't need to worry about this - mostly it's the map module components which use this function.\n *\n * @param  {Number} width                           The width of the projection destination space.\n * @param  {Number} height                          The height of the projection destination space.\n * @param  {Object} featureCollection               The feature collection that will be projected by the returned function. Needed to calculated a good size.\n * @param  {String} featureBoundsCacheKey           Used internally, this is a key for the cache for the expensive part of this computation.\n * @return {Function}                               The projection function.\n */\nexport const swissMapProjection = memoize(\n  (width, height, featureCollection) => geoMercator().fitSize([width, height], featureCollection),\n  // Memoize resolver\n  (width, height, _, featureBoundsCacheKey) =>\n    \"\" + width + \",\" + height + \",\" + featureBoundsCacheKey\n);\n\n/**\n * This is a special d3.geoPath generator function tailored for rendering maps of\n * Switzerland. The values are chosen specifically to optimize path generation for\n * Swiss map regions and is not necessarily optimal for displaying other areas of the globe.\n *\n * @param  {number} width                     The width of the available map space\n * @param  {number} height                    The height of the available map space\n * @param  {GeoJson} featureCollection        The collection of features to be displayed in the map space\n * @param  {string} [featureBoundsCacheKey]   A string key to use to cache the result of the bounds calculation, which is expensive.\n *                                            This key should be the same every time the same featureCollection object\n *                                            is passed to this function. If the featureCollection is different, use a different\n *                                            cache key. If provided, this can enable large performance improvements in map rendering.\n * @return {d3.geoPath}                       A path generator function. This function takes a geojson datum as argument\n *                                            and returns an svg path string which represents that geojson, projected using\n *                                            a map projection optimal for Swiss areas.\n */\nexport const swissMapPath = function (width, height, featureCollection, featureBoundsCacheKey) {\n  return geoPath().projection(\n    swissMapProjection(width, height, featureCollection, featureBoundsCacheKey)\n  );\n};\n\n/**\n * Use this function to calcualate the length in pixels of a distance in meters across the surface of the earth\n * The earth's radius is not constant, so this function uses an approximation for calculating the degree angle of\n * a distance in meters.\n *\n * @param {function} projection     You need to provide a projection function for calculating pixel values from decimal degree\n *                                  coordinates. This function should accept values as [lon, lat] array pairs (like d3's projection functions).\n * @param {array} centerPoint       You need to provide a center point. This point is used as the center of a hypothetical square\n *                                  with side lengths equal to the meter distance to be measured. The center point is required\n *                                  because the pixel size of a given degree distance will be different if that square is located\n *                                  at the equator or at one of the poles. This value should be specified as a [lon, lat] array pair.\n * @param {number} meterDistance    The distance (in meters) for which you want the pixel value\n */\nexport const pixelsFromGeoDistance = function (projection, centerPoint, meterDistance) {\n  // This radius (in meters) is halfway between the radius of the earth at the equator (6378200m) and that at its poles (6356750m).\n  // I figure it's an appropriate approximation for Switzerland, which is at roughly 45deg latitude.\n  const APPROX_EARTH_RADIUS = 6_367_475;\n  const APPROX_EARTH_CIRCUMFERENCE = Math.PI * 2 * APPROX_EARTH_RADIUS;\n  // Compute the size of the angle made by the meter distance\n  const degrees = (meterDistance / APPROX_EARTH_CIRCUMFERENCE) * 360;\n  // Construct a square, centered at centerPoint, with sides that span that number of degrees\n  const halfDegrees = degrees / 2;\n  const bounds = [\n    [centerPoint[0] - halfDegrees, centerPoint[1] - halfDegrees],\n    [centerPoint[0] + halfDegrees, centerPoint[1] + halfDegrees],\n  ];\n\n  // Project those bounds to pixel coordinates using the provided map projection\n  const projBounds = bounds.map(projection);\n  // Depending on the rotation of the map, the sides of the box are not always positive quantities\n  // For example, on a north-is-up map, the pixel y-scale is inverted, so higher latitude degree\n  // values are lower pixel y-values. On a south-is-up map, the opposite is true.\n  const projXDist = Math.abs(projBounds[1][0] - projBounds[0][0]);\n  const projYDist = Math.abs(projBounds[1][1] - projBounds[0][1]);\n  return (projXDist + projYDist) / 2;\n};\n\nexport const GEO_KEY_DEFAULT = \"geoId\";\n\n/**\n * prepareMergedData\n *\n * Merges a dataset with a geojson object by matching elements in the dataset to elements in the geojson.\n * it expects a keyname to be given, which is the key in each data object which has the id of the geojson\n * element to which that data object should be matched. Expects an array of data objects, and a geojson object\n * which has a features array. Each feature is mapped to one data object.\n *\n * @param  {Array} dataset           The array of input data to match\n * @param  {Object} geoJson          The geojson object. This function will attempt to match each geojson feature to a data object\n * @param  {String} keyName          The name of the property on each data object which will be matched with each geojson id.\n * @return {Array}                   An array of objects (one for each element of the geojson's features). Each should have a\n *                                   geoJson property which is the feature, and a datum property which is the matched datum.\n */\nexport const prepareMergedGeoData = function (dataset, geoJson, keyName) {\n  keyName || (keyName = GEO_KEY_DEFAULT);\n\n  // group the input data by map entity id\n  const groupedInputData = Array.isArray(dataset)\n    ? dataset.reduce((m, v) => {\n        m[v[keyName]] = v;\n        return m;\n      }, {})\n    : {};\n\n  // merge the map features and the input data into new objects that include both\n  return geoJson.features.map((feature) => ({\n    geoJson: feature,\n    datum: groupedInputData[feature.id],\n  }));\n};\n\n/**\n * getGeoJsonCenter\n *\n * Gets the geographic centroid of a geojson feature object. Caches the result of the calculation\n * on the object as an optimization (note that this is a coordinate position and is independent\n * of the map projection). If the geoJson object's properties contain a 'center' property, that\n * is expected to be a string of the form \"longitude,latitude\" which will be parsed into a [lon, lat]\n * pair expected by d3's projection functions. These strings can be added to the properties array\n * using the topojson command line tool's -e option (see the Makefile rule for the zurich statistical\n * quarters map for an example of this use).\n *\n * @param  {Object} geoJson                 The geoJson object for which you want the center.\n * @return {Array[float, float]}            The geographical coordinates (in the form [lon, lat]) of the centroid\n *                                          (or user-specified center) of the object.\n */\nexport const getGeoJsonCenter = function (geoJson) {\n  if (!geoJson.properties.cachedCenter) {\n    const setCenter = geoJson.properties.center;\n    geoJson.properties.cachedCenter = setCenter\n      ? setCenter.split(\",\").map(Number.parseFloat)\n      : geoCentroid(geoJson);\n  }\n\n  return geoJson.properties.cachedCenter;\n};\n\n/**\n * widthAdaptiveMapPathStroke\n *\n * A little \"magic\" function for automatically calculating map stroke sizes based on\n * the width of the container they're in. Used for responsive designs.\n *\n * @param  {number} width    The width of the container holding the map.\n * @return {number}          The stroke width that the map elements should have.\n */\nexport const widthAdaptiveMapPathStroke = function (width) {\n  return Math.min(Math.max(0.8, width / 400), 1.1);\n};\n"],"names":["STADT_KREISE_KEY","STATISTISCHE_QUARTIERE_KEY","STATISTISCHE_ZONEN_KEY","WAHL_KREISE_KEY","AGGLOMERATION_2012_KEY","SWITZERLAND_KEY","swissMapProjection","memoize","width","height","featureCollection","geoMercator","fitSize","_","featureBoundsCacheKey","swissMapPath","geoPath","projection","pixelsFromGeoDistance","centerPoint","meterDistance","APPROX_EARTH_RADIUS","APPROX_EARTH_CIRCUMFERENCE","Math","PI","degrees","halfDegrees","bounds","projBounds","map","projXDist","abs","projYDist","GEO_KEY_DEFAULT","prepareMergedGeoData","dataset","geoJson","keyName","groupedInputData","Array","isArray","reduce","m","v","features","feature","datum","id","getGeoJsonCenter","properties","cachedCenter","setCenter","center","split","Number","parseFloat","geoCentroid","widthAdaptiveMapPathStroke","min","max"],"mappings":"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"}