{"version":3,"file":"responsiveProps.js","sources":["../src/responsiveProps.js"],"sourcesContent":["/**\n * ResponsiveProps module\n *\n * @module sszvis/responsiveProps\n *\n *\n *\n * The module should be configured with any number of different properties that change\n * based on breakpoints, plus (optional) breakpoint configuration, and then called\n * as a function. You must pass in an object with 'width' and 'screenHeight' properties.\n * This is the kind of thing which is returned from sszvis.bounds and sszvis.measureDimensions.\n *\n *\n * The return value of the function call is an object which has properties corresponding to\n * the properties you configured before. The property values are decided based on testing the breakpoints\n * against the measured values and finding the first one in which the measured values fit.\n *\n * Example usage:\n *\n * var queryProps = sszvis.responsiveProps()\n *   .breakpoints([\n *     { name: 'small', width:  400 },\n *     { name: 'medium', width:  800 },\n *     { name: 'large', width: 1000 }\n *   ])\n *   .prop('axisOrientation', {\n *     medium: 'left',\n *     _: 'bottom'\n *   })\n *   .prop('height', {\n *     small: function(w) { return w / (16 / 9); },\n *     medium: function(w) { return w / (20 / 9); },\n *     large: function(w) { return w / (28 / 9); },\n *     _: function(w) { return w / (38 / 9); }\n *   })\n *   .prop('numAxisTicks', {\n *     small: 4,\n *     medium: 8,\n *     large: 12,\n *     _: 16\n *   });\n *\n * var props = queryProps(sszvis.measureDimensions('#sszvis-chart'));\n * --- OR ---\n * var props = queryProps(sszvis.bounds({ ... }, '#sszvis-chart'));\n *\n * ... use props.axisOrientation, props.height, and props.numAxisTicks ...\n *\n * @returns {responsiveProps}\n */\n\nimport {\n  breakpointCreateSpec,\n  breakpointDefaultSpec,\n  breakpointFindByName,\n  breakpointMatch,\n} from \"./breakpoint.js\";\nimport * as fn from \"./fn.js\";\nimport * as logger from \"./logger.js\";\n\n/* Exported module\n----------------------------------------------- */\nexport function responsiveProps() {\n  let breakpointSpec = breakpointDefaultSpec();\n  const propsConfig = {};\n\n  /**\n   * Constructor\n   *\n   * @param   {{width: number, screenHeight: number}} arg1 Accepts a 'measurements' object with a\n   *          'width' property and a 'screenHeight' property. This makes it possible to pass\n   *          in a sszvis.bounds object or the result of sszvis.measureDimensions.\n   *\n   * @returns {Object.<string, any>} A map of all properties for the currently selected\n   *          breakpoint as defined by the parameter `arg1`\n   */\n  function _responsiveProps(measurement) {\n    if (!fn.isObject(measurement) || !isBounds(measurement)) {\n      logger.warn(\"Could not determine the current breakpoint, returning the default props\");\n      // We choose the _ option for all configured props as a default.\n      return Object.keys(propsConfig).reduce((memo, val, key) => {\n        memo[key] = val._;\n        return memo;\n      }, {});\n    }\n\n    // Finds out which breakpoints the provided measurements match up with\n    const matchingBreakpoints = breakpointMatch(breakpointSpec, measurement);\n\n    return Object.keys(propsConfig).reduce((memo, propKey) => {\n      const propSpec = propsConfig[propKey];\n\n      if (!validatePropSpec(propSpec, breakpointSpec)) {\n        logger.warn(\n          'responsiveProps was given an invalid propSpec for property: \"' +\n            propKey +\n            '\". The spec: ',\n          propSpec\n        );\n        return memo;\n      }\n\n      // Find the first breakpoint entry in the propSpec which matches one of the matched breakpoints\n      // This function should always at least find '_' at the end of the array.\n      const matchedBreakpoint = fn.find((bp) => fn.defined(propSpec[bp.name]), matchingBreakpoints);\n      // the value in the query object for that property equals the propSpec value as a functor,\n      // invoked if necessary with the current width. Providing the width allows aspect ratio\n      // calculations based on element width.\n      memo[propKey] = propSpec[matchedBreakpoint.name](measurement.width);\n\n      return memo;\n    }, {});\n  }\n\n  /**\n   * responsiveProps.prop\n   *\n   * Define a responsive property that can assume different values depending on the\n   * currently active breakpoint.\n   *\n   * @example\n   * var queryProps = sszvis.responsiveProps()\n   *   .prop('height', {\n   *     palm: function(width) { return width /  (4/3); },\n   *     lap:  function(width) { return width / (16/9); },\n   *     _: 600 // You must always define a default case\n   *   });\n   *\n   * The algorithm looks for the lowest applicable breakpoint. If a breakpoint's width or\n   * screenHeight are larger than the current container and screen dimensions, its properties\n   * will not apply. In case no breakpoint matches, the fallback value is used; it must always\n   * be provided with the key name '_'.\n   *\n   * Each value can be either a raw value or a function which takes the current width\n   * and returns a value for the property. These functions can be used to lazily calculate\n   * properties (they are only executed when the module is called as a function),\n   * and to change property values for a given breakpoint as a function of the width,\n   * for example to do height calculation with a custom aspect ratio.\n   *\n   * @param {string} propName The name of the property you want to define\n   * @param {Object.<string, (Function(number) -> *|*)>} propSpec A map of breakpoint names to\n   *        property values. Key names must be valid breakpoint names. These can either be the\n   *        default breakpoint names (see sszvis.breakpoint) or user-defined names that match up\n   *        to breakpoints you have provided. Additionally, the fallback key `_` must be defined;\n   *        its value will be used for screens larger than the largest breakpoint. You don't\n   *        have to define all breakpoints; if you skip a breakpoint, the next applicable breakpoint\n   *        in the test list will be used. Values can be either plain values or\n   *        functions that accept the current breakpoint width and return a value.\n   *\n   * @return {responsiveProps}\n   */\n  _responsiveProps.prop = function (propName, propSpec) {\n    propsConfig[propName] = functorizeValues(propSpec);\n    return _responsiveProps;\n  };\n\n  /**\n   * responsiveProps.breakpoints\n   *\n   * Configure custom breakpoints for the responsiveProps. You don't need to call\n   * this method; there are default breakpoints (see sszvis.breakpoint).\n   * You should provide an array of breakpoint specifiers, each one an object with at\n   * least a 'name' property (used as an identifier for the breakpoint), and one or both\n   * of a 'width' or 'screenHeight' property. When choosing a matching breakpoint, the\n   * 'width' will be compared to the provided container width, and the 'screenHeight'\n   * to the window.innerHeight. These values are inclusive, so if the measured value is\n   * equal to or less than the provided breakpoint value, that breakpoint matches.\n   *\n   * This component has default breakpoints which are equal to the ones described\n   * in the sszvis.breakpoint module. This method can also be called without arguments\n   * to get the breakpoints list.\n   *\n   * @param {Array.<Object.<string, (string|number)>>} [bps] Define the breakpoints to be used.\n   *                                                   Object format is:\n   *                                                     {\n   *                                                       name: breakpointname,\n   *                                                       width: (optional) container width of this bp\n   *                                                       screenHeight: (optional) window.innerHeight of this bp\n   *                                                     }\n   *                                                   if neither width nor screenHeight is provided, the breakpoint\n   *                                                   will match all possible dimensions.\n   *\n   * @example\n   * var queryProps = sszvis.responsiveProps()\n   * .breakpoints([\n   *   { name: 'small', width: 300 },\n   *   { name: 'medium', width: 500 },\n   *   { name: 'large', width: 700 }\n   * ])\n   */\n  _responsiveProps.breakpoints = function (bps) {\n    if (arguments.length === 0) {\n      return breakpointSpec;\n    }\n    breakpointSpec = breakpointCreateSpec(bps);\n    return _responsiveProps;\n  };\n\n  return _responsiveProps;\n}\n\n// Helpers\n\nfunction isBounds(arg1) {\n  return (\n    fn.defined(arg1) &&\n    fn.defined(arg1.width) &&\n    fn.defined(arg1.screenWidth) &&\n    fn.defined(arg1.screenHeight)\n  );\n}\n\n/**\n * functorizeValues\n * @prop    {object} obj Original key-value object\n * @returns {object} Same as input object but with all values transformed to fn.functors\n */\nfunction functorizeValues(obj) {\n  return Object.keys(obj).reduce((memo, key) => {\n    memo[key] = fn.functor(obj[key]);\n    return memo;\n  }, {});\n}\n\nfunction validatePropSpec(propSpec, breakpointSpec) {\n  // Ensure that the propSpec contains a '_' value.\n  // This is used as the default value when the test width\n  // is larger than any breakpoint.\n  if (!fn.defined(propSpec._)) {\n    return false;\n  }\n\n  // Validate the properties of the propSpec:\n  // each should be a valid breakpoint name, and its value should be defined\n  for (const breakpointName in propSpec) {\n    if (\n      Object.prototype.hasOwnProperty.call(propSpec, breakpointName) &&\n      breakpointName !== \"_\" &&\n      !fn.defined(breakpointFindByName(breakpointSpec, breakpointName))\n    ) {\n      return false;\n    }\n  }\n\n  // All checks passed, propSpec is valid\n  return true;\n}\n"],"names":["responsiveProps","breakpointSpec","breakpointDefaultSpec","propsConfig","_responsiveProps","measurement","fn","isBounds","logger","Object","keys","reduce","memo","val","key","_","matchingBreakpoints","breakpointMatch","propKey","propSpec","validatePropSpec","matchedBreakpoint","bp","name","width","prop","propName","functorizeValues","breakpoints","bps","arguments","length","breakpointCreateSpec","arg1","screenWidth","screenHeight","obj","breakpointName","prototype","hasOwnProperty","call","breakpointFindByName"],"mappings":"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"}