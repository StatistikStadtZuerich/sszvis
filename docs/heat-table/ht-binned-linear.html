
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Heat Table â€“ Binned</title>
</head>
<body style="margin:0;padding:0;">
<link href='../../sszvis.css' rel='stylesheet' />
<script src="../../vendor/d3/d3.min.js"></script>
<script src="../../sszvis.js"></script>

<div id="sszvis-chart"></div>

<script data-catalog-project-expose="script.js">
(function(d3, sszvis) {
  'use strict';

  if (sszvis.fallback.unsupported()) {
    sszvis.fallback.render('#sszvis-chart');
    return;
  }


  /* Configuration
  ----------------------------------------------- */
  var TITLE = 'Diagrammtitel';
  var DESCRIPTION = 'Kurze Beschreibung des Inhalts dieses Diagramms';
  // these are the internal edges of the bins used for the color scale
  // IMPORTANT: because of the way d3.scale.threshold works,
  // do not specify fixed upper and lower bounds
  // anything less than or equal to the first element in BIN_EDGES will be grouped in the first bin,
  // and anything greater than or equal to the last element will be grouped in the last bin
  var BIN_EDGES = d3.range(100, 1000, 100);


  /* Shortcuts
  ----------------------------------------------- */
  var xAcc = sszvis.fn.prop('g1');
  var yAcc = sszvis.fn.prop('g2');
  var cAcc = sszvis.fn.prop('value');


  /* Application state
  ----------------------------------------------- */
  var state = {
    data: [],
    g1List: [],
    g2List: [],
    valueDomain: [0, 0],
    selection: []
  };


  /* State transitions
  ----------------------------------------------- */
  var actions = {
    prepareState: function(data) {
      state.data = data;
      state.g1List = sszvis.fn.set(state.data, xAcc);
      state.g2List = sszvis.fn.set(state.data, yAcc);
      state.valueDomain = d3.extent(state.data, cAcc);

      render(state);
    },

    showTooltip: function(datum) {
      state.selection = [datum];
      render(state);
    },

    hideTooltip: function() {
      state.selection = [];
      render(state);
    }
  };


  /* Data initialization
  ----------------------------------------------- */
  d3.csv('data/HT_binned_linear.csv')
    .row(function(d) {
      return {
        g1: d['Group1'],
        g2: d['Group2'],
        value: sszvis.parse.number(d['Value'])
      };
    })
    .get(function(error, data) {
      if (error) {
        sszvis.loadError(error);
        return;
      }
      actions.prepareState(data);
    });


  /* Render
  ----------------------------------------------- */
  function render(state) {
    var squarePadding = 2;
    // heatTableDimensions calculates a set of useful properties for configuring the heat table.
    // give it the targeted width (final width will not necessarily match this), the padding between squares, and the number of squares
    // in each dimension (x, then y)
    var tableDimensions = sszvis.layout.heatTableDimensions(sszvis.bounds.DEFAULT_WIDTH, squarePadding, state.g1List.length, state.g2List.length);
    // this object represents the padding around the heat table. The centeredOffset value is computed by tableDimensions in such a way that using it as padding bounds will center the table within the chart area
    var tablePadding = {
      top: 60,
      right: tableDimensions.centeredOffset,
      bottom: 80,
      left: tableDimensions.centeredOffset
    };
    // construct the bounds as usual, but add the left and right padding to the width, and the top and bottom padding to the height
    // This is because, when bounds are being constructed, the padding is subtracted from width and height to provide innerWidth and innerHeight, but we want these values to represent the table's dimensions
    var bounds = sszvis.bounds({
      width: tablePadding.left + tableDimensions.width + tablePadding.right,
      left: tablePadding.left,
      right: tablePadding.right,
      height: tablePadding.top + tableDimensions.height + tablePadding.bottom,
      top: tablePadding.top,
      bottom: tablePadding.bottom
    });


    // Scales

    var xScale = d3.scale.ordinal()
      .rangeBands([0, tableDimensions.width], tableDimensions.padRatio, 0)
      .domain(state.g1List);

    var yScale = d3.scale.ordinal()
      .rangeBands([0, tableDimensions.height], tableDimensions.padRatio, 0)
      .domain(state.g2List);

    // create a linear color interpolator for generating the output range of bin colors
    var interpolateColor = sszvis.color.divVal()
      .domain(state.valueDomain);

    // the color bins are created by taking samples at equal spots along the data domain
    // binColors.length must equal BIN_EDGES.length + 1
    var binColors = d3.range(0, 10001, 110).map(interpolateColor);
    // for the threshold scale, the number of values in the range must be one greater than the
    // number of values in the domain.

    var colorScale = d3.scale.threshold()
      .domain(BIN_EDGES)
      .range(binColors);

    var xValue = sszvis.fn.compose(xScale, xAcc);
    var yValue = sszvis.fn.compose(yScale, yAcc);
    var cValue = sszvis.fn.compose(colorScale, cAcc);


    // Layers

    var chartLayer = sszvis.createSvgLayer('#sszvis-chart', bounds, {
        title: TITLE,
        description: DESCRIPTION
      })
      .datum(state.data);

    var tooltipLayer = sszvis.createHtmlLayer('#sszvis-chart')
      .datum(state.selection);


    // Components

    var barGen = sszvis.component.bar()
      .x(xValue)
      .y(yValue)
      .width(tableDimensions.side)
      .height(tableDimensions.side)
      .fill(cValue)
      .stroke(function(d) {
        return sszvis.fn.contains(state.selection, d) ? sszvis.color.slightlyDarker(cValue(d)) : 'none';
      });

    var xAxis = sszvis.axis.x.ordinal()
      .scale(xScale)
      .orient('top')
      .tickSize(0, 0)
      .tickPadding(0)
      .title('Group 1')
      .titleAnchor('middle')
      .titleCenter(true)
      .dyTitle(-20)
      .highlightTick(function(tickValue) {
        return state.selection.some(function(d) {
          return xAcc(d) === tickValue;
        });
      });

    var yAxis = sszvis.axis.y.ordinal()
      .scale(yScale)
      .orient('left')
      .title('Group 2')
      .titleVertical(true)
      .titleAnchor('middle')
      .titleCenter(true)
      .dxTitle(-20)
      .highlightTick(function(tickValue) {
        return state.selection.some(function(d) {
          return yAcc(d) === tickValue;
        });
      });

    var legend = sszvis.legend.binnedColorScale()
      .scale(colorScale)
      .displayValues(BIN_EDGES)
      .endpoints(state.valueDomain)
      .width(tableDimensions.width)
      .labelFormat(sszvis.format.number);

    var tooltipHeaderText = sszvis.svgUtils.modularText.html().bold('Units');

    var tooltip = sszvis.annotation.tooltip()
      .renderInto(tooltipLayer)
      .header(tooltipHeaderText)
      .body(function(d) {
        return [
          ['Group 1', xAcc(d)],
          ['Group 2', yAcc(d)],
          ['Wert', cAcc(d)]
        ];
      })
      .visible(isSelected);


    // Rendering

    var bars = chartLayer.selectGroup('bars')
      .call(barGen);

    bars.selectAll('[data-tooltip-anchor]')
      .call(tooltip);


    chartLayer.selectGroup('xAxis')
      .attr('transform', sszvis.svgUtils.translateString(0, -10))
      .call(xAxis);

    chartLayer.selectGroup('yAxis')
      .attr('transform', sszvis.svgUtils.translateString(-10, 0))
      .call(yAxis);

    chartLayer.selectGroup('legend')
      .attr('transform', sszvis.svgUtils.translateString(0, bounds.innerHeight + 40))
      .call(legend);


    // Interaction

    bars.selectAll('.sszvis-bar')
      .on('mouseover', actions.showTooltip)
      .on('mouseout',  actions.hideTooltip);

  }


  /* Helper functions
  ----------------------------------------------- */
  function isSelected(d) {
    return sszvis.fn.contains(state.selection, d);
  }


}(d3, sszvis));
</script>
</body>
</html>
