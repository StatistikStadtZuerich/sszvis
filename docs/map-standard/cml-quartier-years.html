<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Map</title>
</head>
<body style="margin:0;padding:0;">
<link href='../../sszvis.css' rel='stylesheet' />
<script src="../../vendor/d3/d3.min.js"></script>
<script src="../../vendor/topojson/topojson.js"></script>
<script src="../../sszvis.js"></script>
<!-- load the map module -->
<script src="../../map-modules/sszvis-map-zurich-statistischequartiere.js"></script>

<div id="sszvis-chart"></div>

<script data-catalog-project-expose="script.js">
(function(d3, topojson, sszvis) {
  'use strict';

  if (sszvis.fallback.unsupported()) {
    sszvis.fallback.render('#sszvis-chart');
    return;
  }


  /* Configuration
  ----------------------------------------------- */
  var TITLE = 'Diagrammtitel';
  var DESCRIPTION = 'Kurze Beschreibung des Inhalts dieses Diagramms';
  // Only select an entity if the distance to an input value is lower than
  // this threshold.
  var VALUE_PROXIMITY_THRESHOLD = 800;
  var propsQuery = sszvis.responsiveProps()
    .prop('height', {
      narrow: 600,
      tablet: sszvis.aspectRatio(4, 3),
      wide: sszvis.aspectRatio(2, 1),
      _: sszvis.aspectRatio(4, 1)
    })
    .prop('lineChartPadding', {
      narrow: 12,
      tablet: function(w) { return w / 10; },
      wide: function(w) { return w / 5; },
      _: function(w) { return w / 4; }
    });


  /* Shortcuts
  ----------------------------------------------- */
  var vAcc = sszvis.fn.prop('value');
  var yearAcc = sszvis.fn.prop('year');
  var geoIdAcc = sszvis.fn.prop('geoId');
  var nameAcc = sszvis.fn.prop('name');
  var mDatumAcc = sszvis.fn.prop('datum');


  /* Application state
  ----------------------------------------------- */
  var state = {
    data: [],
    valueDomain: [0, 0],
    yearDomain: [new Date(), new Date()],
    lineData: [],
    currentYear: new Date(),
    currentMapData: [],
    highlightEntity: null,
    lineBaseColor: sszvis.color.gry()(0),
    lineHighlightColor: sszvis.color.qual12()(0),
    mapHighlightData: [],
    lineHighlightData: []
  };


  /* State transitions
  ----------------------------------------------- */
  var actions = {
    prepareState: function(data) {
      state.data = data;
      state.valueDomain = [0, d3.max(state.data, vAcc)];
      state.yearDomain = d3.extent(state.data, yearAcc);

      // set up a cascade for sorting data into arrays based on which geoId they belong to
      var cascadedData = sszvis.cascade()
        .arrayBy(geoIdAcc)
        .sort(function(a, b) {
          return d3.ascending(yearAcc(a), yearAcc(b));
        })
        .apply(state.data);

      // transform the data into line objects, one for each line
      state.lineData = cascadedData.map(function(lineData) {
        return {
          geoId: geoIdAcc(sszvis.fn.first(lineData)),
          values: lineData
        };
      });

      // calculate a line which represents the average values in the dataset
      var averageLineValues = cascadedData.reduce(function(m, lineData) {
        lineData.forEach(function(datum, index) {
          if (!m[index]) {
            m[index] = {
              // isAverageValue is used by the handleRuler component to determine the correct tooltip
              isAverageValue: true,
              year: datum.year,
              value: 0
            };
          }
          m[index].value += Math.round(datum.value / cascadedData.length);
        });
        return m;
      }, []);
      state.averageLine = {
        // the average line can be identified because it has a null geoId
        geoId: null,
        values: averageLineValues
      };
      // add the average line to the lineData
      state.lineData.push(state.averageLine);

      actions.resetYear();
    },

    changeEntityNearDate: function(inputValue, inputDate) {
      // find the closest year to the mouse
      var closestYear = yearAcc(closestDatum(state.data, yearAcc, inputDate));

      // within the closest year's data values, find the one closest to the mouse position
      var entitiesForYear = state.data.filter(function(d) {
        return sszvis.fn.stringEqual(closestYear, yearAcc(d));
      })
      // entries have to be sorted so that d3.bisector will work on it.
      .sort(sortWithAcc(vAcc));

      // Find the closest entity to the mouse
      var closestEntity = inputValue === null ? null : closestDatum(entitiesForYear, vAcc, inputValue);

      // Only re-render when the entity has changed
      // Only highlight the entity if it is close enough to the inputValue
      if (state.highlightEntity !== closestEntity && Math.abs(inputValue - vAcc(closestEntity)) < VALUE_PROXIMITY_THRESHOLD) {
        // select the entity's sibling from the currently selected year instead
        // of from what's near the mouse in order to highlight the correct
        // entity on the ruler
        state.highlightEntity = sszvis.fn.find(function(d) {
          return geoIdAcc(d) === geoIdAcc(closestEntity);
        }, state.currentMapData);

        actions.setHighlights();
      }
    },

    changeYear: function(inputDate) {
      // find the closest year to the mouse
      var closestYear = yearAcc(closestDatum(state.data, yearAcc, inputDate));

      // this is an optimization to ensure that the chart is only re-rendered when underlying state has changed
      if (state.currentYear !== closestYear) {
        state.currentYear = closestYear;
        state.currentMapData = state.data.filter(function(v) {
          return yearAcc(v).getFullYear() === state.currentYear.getFullYear();
        })
        // currentMapData has to be sorted so that d3.bisector will work on it.
        .sort(sortWithAcc(vAcc));

        state.highlightEntity = findEntityWithGeoId(geoIdAcc(state.highlightEntity || {}), state.currentMapData);

        actions.setHighlights();
      }
    },

    // resets the active year
    resetYear: function() {
      var mostRecentDate = d3.max(state.yearDomain);
      actions.changeYear(mostRecentDate);
    },

    // called when moving over map entities with the mouse. Highlights certain entities
    changeMapEntity: function(d) {
      state.highlightEntity = d;

      actions.setHighlights();
    },

    // reset the highlighted map entity
    resetMapEntity: function() {
      state.highlightEntity = null;

      actions.setHighlights();
    },

    setHighlights: function() {
      // highlightData passed to the map is slightly different from the data passed to the line chart.
      // When no entity is highlighted, the map shows nothing special, but the line chart shows the average line.
      state.mapHighlightData = state.highlightEntity ? [state.highlightEntity] : [];
      state.lineHighlightData = state.highlightEntity ? [state.highlightEntity] : state.averageLine.values.filter(function(averageObj) {
        return yearAcc(averageObj).getFullYear() === state.currentYear.getFullYear();
      });

      render(state);
    }
  };


  /* Data initialization
  ----------------------------------------------- */
  d3.csv('data/CML_quartier_years.csv')
    .row(function(d) {
      return {
        geoId: sszvis.parse.number(d['QNr']),
        year: sszvis.parse.year(d['Jahr']),
        value: sszvis.parse.number(d['Anzahl']),
        name: d['Qname']
      };
    })
    .get(function(error, data) {
      if (error) {
        sszvis.loadError(error);
        return;
      }
      actions.prepareState(data);
    });


  /* Render
  ----------------------------------------------- */
  function render(state) {
    var props = propsQuery(sszvis.fn.elementWidth('#sszvis-chart'));

    var outerBounds = sszvis.bounds({
      height: props.height,
      top: 0,
      bottom: 0
    }, '#sszvis-chart');

    // The line chart's height is 1/4th of the default height plus top and bottom padding
    var lineChartHeight = outerBounds.height * 2 / 7;
    var lineChartTopPad = 18, lineChartBottomPad = 20;
    // The map height is the rest
    var mapHeight = outerBounds.height - lineChartHeight;
    var mapTopPad = 10, mapBottomPad = 45;
    var colorScalePad = 15;

    // bounds for the map section of the chart
    var mapBounds = sszvis.bounds({
      height: mapHeight - mapTopPad - mapBottomPad,
      top: mapTopPad,
      bottom: mapBottomPad,
      right: 0,
      left: 0
    }, '#sszvis-chart');

    // bounds for the line chart section
    var lineChartBounds = sszvis.bounds({
      height: lineChartHeight - lineChartTopPad - lineChartBottomPad,
      top: lineChartTopPad,
      bottom: lineChartBottomPad,
      left: props.lineChartPadding,
      right: props.lineChartPadding
    }, '#sszvis-chart');


    // Scales

    // map fill scale
    var fillScale = sszvis.color.seqBlu()
      .domain(state.valueDomain);

    // line chart scales
    var xScale = d3.time.scale()
      .domain(state.yearDomain)
      .range([0, lineChartBounds.innerWidth]);

    var yScale = d3.scale.linear()
      .domain(state.valueDomain)
      .range([lineChartBounds.innerHeight, 0]);


    // Layers

    var chart = sszvis.createSvgLayer('#sszvis-chart', outerBounds, {
      title: TITLE,
      description: DESCRIPTION
    });

    var map = chart.selectGroup('map')
      .attr('transform', sszvis.svgUtils.translateString(mapBounds.padding.left, mapBounds.padding.top))
      .datum(state.currentMapData);

    var lineChart = chart.selectGroup('line')
      .attr('transform', sszvis.svgUtils.translateString(lineChartBounds.padding.left, mapBounds.height + lineChartBounds.padding.top))
      .datum(state.lineData);

    var highlightLayer = chart.selectGroup('highlight')
      .attr('transform', sszvis.svgUtils.translateString(lineChartBounds.padding.left, mapBounds.height + lineChartBounds.padding.top))
      .datum(state.lineHighlightData);

    var tooltipLayer = sszvis.createHtmlLayer('#sszvis-chart', outerBounds)
      .datum(state.mapHighlightData);


    // Components

    var mapMaker = sszvis.map.zurichStatistischeQuartiere()
      .highlight(state.mapHighlightData)
      .highlightStroke(sszvis.fn.compose(sszvis.color.muchDarker, fillScale, vAcc))
      .width(mapBounds.innerWidth)
      .height(mapBounds.innerHeight)
      .transitionColor(false)
      .fill(sszvis.fn.compose(fillScale, vAcc));

    var lineMaker = sszvis.component.line()
      // passing a key function here is important, because the DOM order of the lines is changed
      // by highlighting a line. When a line is highlighted, it is sorted to the front of other lines.
      // This sorting is performed later in the code.
      .key(sszvis.fn.prop('geoId'))
      .valuesAccessor(sszvis.fn.prop('values'))
      .x(sszvis.fn.compose(xScale, yearAcc))
      .y(sszvis.fn.compose(yScale, vAcc))
      .stroke(function(lineData) {
        // this function determines whether the line is the highlighted line or not
        var isBlue;
        if (!state.highlightEntity) {
          isBlue = lineData.geoId === null; // if so, this is the average line
        } else {
          isBlue = state.highlightEntity.geoId === lineData.geoId;
        }
        return isBlue ? state.lineHighlightColor : state.lineBaseColor;
      });

    var xTickValues = xScale
      .ticks(4)
      .concat(state.currentYear);

    var lineXAxis = sszvis.axis.x.time()
      .scale(xScale)
      .orient('bottom')
      .tickValues(xTickValues)
      .highlightTick(tickIsSelected);

    var lineYAxis = sszvis.axis.y()
      .scale(yScale)
      .ticks(3)
      .orient('right')
      .contour(true);

    var rulerLabel = sszvis.svgUtils.modularText.svg()
      .bold(sszvis.fn.compose(sszvis.format.number, vAcc))
      .plain(function(d) {
        return d.isAverageValue ? 'Durchschnitt' : d.name;
      });

    // The bar which marks the current year and shows the value of the highlighted entity
    var handleRuler = sszvis.control.handleRuler()
      .x(xScale(state.currentYear))
      .y(sszvis.fn.compose(yScale, vAcc))
      .top(0)
      .bottom(lineChartBounds.innerHeight)
      .flip(function(d) {
        return xScale(yearAcc(d)) >= lineChartBounds.innerWidth / 2;
      })
      .color(sszvis.color.qual12())
      .label(rulerLabel);

    // see the comment by the tooltip in docs/map-standard/kreis.html for more information
    // about accesing data properties of map entities.
    var tooltipHeader = sszvis.svgUtils.modularText.html()
      .bold(sszvis.fn.compose(nameAcc, mDatumAcc));

    var tooltip = sszvis.annotation.tooltip()
      .renderInto(tooltipLayer)
      .header(tooltipHeader)
      .body(function(d) {
        return [
          ['Jahr', sszvis.format.year(yearAcc(mDatumAcc(d)))],
          ['Einwohner', sszvis.format.number(vAcc(mDatumAcc(d)))]
        ];
      })
      .visible(entityIsSelected);

    var legend = sszvis.legend.linearColorScale()
      .scale(fillScale)
      .width(lineChartBounds.innerWidth / 2)
      .labelFormat(sszvis.format.number);

    // Rendering

    map.call(mapMaker);

    map.selectAll('[data-tooltip-anchor]')
      .call(tooltip);

    lineChart.call(lineMaker);

    // this sorts the highlighted line to the front of all lines
    lineChart.selectAll('.sszvis-line').sort(function(a, b) {
      var highlightId = state.highlightEntity ? state.highlightEntity.geoId : null;
      return a.geoId === highlightId ? 1 : b.geoId === highlightId ? -1 : 0;
    });

    lineChart.selectGroup('xAxis')
      .attr('transform', sszvis.svgUtils.translateString(0, lineChartBounds.innerHeight))
      .call(lineXAxis);

    lineChart.selectGroup('yAxis')
      .call(lineYAxis);

    highlightLayer.selectGroup('handleRuler')
      .call(handleRuler);

    // for Zurich maps, the color legend should be positioned 60 pixels below the bottom of the map
    chart.selectGroup('legend')
      .attr('transform', sszvis.svgUtils.translateString(lineChartBounds.padding.left + lineChartBounds.innerWidth / 4, mapBounds.padding.top + mapBounds.innerHeight + colorScalePad))
      .call(legend);


    // Interaction

    mapMaker
      .on('over', actions.changeMapEntity)
      .on('out', actions.resetMapEntity);

    // add the hover behavior for the line chart, including top padding so that
    // the area around the slide bar handle is responsive to mouse events.
    var hoverBehavior = sszvis.behavior.move()
      .xScale(xScale)
      .yScale(yScale)
      .padding({ top: 30 })
      .draggable(true)
      .on('drag', actions.changeYear)
      .on('move', function(date, entity){
        actions.changeEntityNearDate(entity, date);
      })
      .on('end', actions.resetMapEntity);

    highlightLayer.selectGroup('interaction')
      .call(hoverBehavior);

    sszvis.behavior.resize().on('resize', function() { render(state); });
  }


  /* Helper functions
  ----------------------------------------------- */
  // given a dataset, an accessor, and a value, find the closest datum in the dataset to that value
  function closestDatum(data, accessor, value) {
    var i = d3.bisector(accessor).left(data, value, 1);
    var d0 = data[i - 1];
    var d1 = data[i] || d0;
    return value - accessor(d0) > accessor(d1) - value ? d1 : d0;
  }

  function findEntityWithGeoId(geoId, data) {
    return sszvis.fn.find(function(d) {
      return geoIdAcc(d) === geoId;
    }, data);
  }

  function sortWithAcc(acc) {
    return function(a, b) {
      return d3.ascending(acc(a), acc(b));
    };
  }

  function tickIsSelected(d) {
    return sszvis.fn.stringEqual(state.currentYear, d);
  }

  function entityIsSelected(d) {
    return state.highlightEntity === mDatumAcc(d);
  }


}(d3, topojson, sszvis));
</script>
</body>
</html>
