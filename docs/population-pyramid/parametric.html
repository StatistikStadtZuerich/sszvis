<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Population Pyramid</title>
</head>
<body style="margin:0;padding:0;">
<link href='../../sszvis.css' rel='stylesheet' />
<script src="../../vendor/d3/d3.min.js"></script>
<script src="../../sszvis.js"></script>

<div id="sszvis-chart"></div>

<script data-catalog-project-expose="script.js">
(function(d3, sszvis) {
  'use strict';

  if (sszvis.fallback.unsupported()) {
    sszvis.fallback.render('#sszvis-chart');
    return;
  }


  /* Configuration
  ----------------------------------------------- */
var config = {
    dataPath: 'data/BP_basic.csv',
    title: '',
    description: '', 
    ageColumn: 'Alter',
    genderColumn: 'Geschlecht',
    valueColumn: 'Anzahl',
    yLabel: '',
    xLabel: '',
    xTicks: null,   // Replace null with a cardinal number to specify the number of ticks
    fallback: false //optional, creates vertical lines for the x-ticks when true
  };


  /* Shortcuts
  ----------------------------------------------- */
  var aAcc = sszvis.fn.prop('age');
  var gAcc = sszvis.fn.prop('gender');
  var vAcc = sszvis.fn.prop('value');
  var womenAcc = sszvis.fn.prop('Frauen');
  var menAcc = sszvis.fn.prop('Männer');


  /* Application state
  ----------------------------------------------- */
  var state = {
    data: [],
    ages: [],
    ageExtent: [],
    groups: [],
    maxValue: 0,
    binnedData: [],
    populations: {},
    selectedAge: []
  };


  /* State transitions
  ----------------------------------------------- */
  var actions = {
    prepareState: function(data) {
      state.data = data;
      state.groups = sszvis.fn.set(state.data, gAcc);

      var grouper = sszvis.cascade()
        .objectBy(gAcc)
        .sort(function(a, b) {
          // Sort the groups in order of ascending age
          return d3.ascending(aAcc(a), aAcc(b));
        });

      var groupedData = grouper.apply(state.data);

      // This example bins the data into five-year age ranges.
      // It uses d3.median to compute the value of a bin.

      // compute bins
      var binnedData = [],
          // The number of data points to include in each bin
          binStep = 5,
          // A list of age groups in the dataset, used for the y-axis scale
          ages = [],
          // A lookup index to aid in creating a smooth tooltip experience. The
          // lookup table allows us to use a continuous range of mouse input and map each
          // value to a categorical age range.
          ageLookupIndex = [];
      for (var group in groupedData) {
        // perform the binning on each group separately
        var sourceArr = groupedData[group];
        // loop through the elements in the group five at a time
        for (var i = 0, l = sourceArr.length; i < l; i += binStep) {
          // create a name for the age range
          var ageListing = aAcc(sourceArr[i]) + '–' + aAcc(sourceArr[i + binStep - 1]);
          // add the name to the list of ages
          ages.push(ageListing);
          // add the binned datum (the structure mimics that of the un-binned data)
          binnedData.push({
            age: ageListing,
            gender: group,
            // here, calculate the median value of the slice of data
            value: d3.median(sourceArr.slice(i, i + binStep), vAcc)
          });
          for (var indexIter = i, lastIndex = i + binStep; indexIter < lastIndex; ++indexIter) {
            // add the age listing (e.g. "10 - 14") to the ageLookupIndex
            // note that this overwrites whatever was already here. If one group is missing entries
            // for certain ages which the other contains, this pattern could create age lookup problems
            ageLookupIndex[aAcc(sourceArr[indexIter])] = ageListing;
          }
        }
      }

      // save data on state which will be used in later steps
      // binned data, ungrouped
      state.binnedData = binnedData;
      // group the bin data. This data set is bound to the chart
      state.populations = grouper.apply(binnedData);
      // save the age lookup index
      state.ageLookupIndex = ageLookupIndex;

      // use the unique age listings as the basis for the ordinal y-scale
      state.ages = sszvis.fn.set(ages);
      // get the age extent (these ages are numbers, not strings) from the data
      // this is used to configure the mouseover behavior
      state.ageExtent = d3.extent(state.data, aAcc);
      // get the maximum binned value, for configuring the horizontal scale
      state.maxValue = d3.max(state.binnedData, vAcc);

      render(state);
    },

    selectBar: function(x, age) {
      // use the age lookup index to figure out which age range is closest
      // to the mouse
      var nearestAgeRange = state.ageLookupIndex[Math.floor(age)];
      // find the binned data rows with that age range
      var rows = state.binnedData.filter(function(v) {
        return aAcc(v) === nearestAgeRange;
      });

      // set the data for the tooltip
      state.selectedAge = {
        age: nearestAgeRange,
        rows: rows
      };

      render(state);
    },

    deselectBar: function() {
      state.selectedAge = [];
      render(state);
    }
  };


  /* Data initialization
  ----------------------------------------------- */
  d3.csv(config.dataPath)
    .row(function(d) {
      return {
        age: sszvis.parse.number(d[config.ageColumn]),
        gender: d[config.genderColumn],
        value: sszvis.parse.number(d[config.valueColumn])
      };
    })
    .get(function(error, data) {
      if (error) {
        sszvis.loadError(error);
        return;
      }
      actions.prepareState(data);
    });


  /* Render
  ----------------------------------------------- */
  function render(state) {
    var defaultHeight = sszvis.bounds.DEFAULT_WIDTH / sszvis.bounds.RATIO;
    var pyramidDimensions = sszvis.layout.populationPyramidLayout(defaultHeight, state.ages.length);
    var bounds = sszvis.bounds({ height: 25 + pyramidDimensions.totalHeight + 86, top: 25, bottom: 86 });


    // Scales

    var lengthScale = d3.scale.linear()
      .domain([0, state.maxValue])
      .range([0, bounds.innerWidth / 2]);

    var positionScale = d3.scale.ordinal()
      .domain(state.ages)
      .range(pyramidDimensions.positions);

    var colorScale = sszvis.color.qual6()
      .domain(state.groups);


    // Layers

    var chartLayer = sszvis.createSvgLayer('#sszvis-chart', bounds, {
      title: config.title,
      description: config.description,
    })
      .datum(state.populations);

    var tooltipLayer = sszvis.createHtmlLayer('#sszvis-chart')
      .datum(state.selectedAge);


    // Components

    var pyramid = sszvis.component.pyramid()
      .barFill(function(d) {
        var c = colorScale(gAcc(d));
        return aAcc(d) === state.selectedAge.age ? sszvis.color.slightlyDarker(c) : c;
      })
      .barPosition(sszvis.fn.compose(positionScale, aAcc))
      .barHeight(pyramidDimensions.barHeight)
      .barWidth(sszvis.fn.compose(lengthScale, vAcc))
      .leftAccessor(womenAcc)
      .rightAccessor(menAcc);

    var xAxis = sszvis.axis.x.pyramid()
      .scale(lengthScale)
      .orient('bottom')
      .title(config.xLabel)
      .ticks (config.xTicks)
      .tickLength(config.fallback ? bounds.innerWidth : null)
      .titleAnchor('middle')
      .titleCenter(true);

    var yAxis = sszvis.axis.y.ordinal()
      .scale(positionScale)
      .orient('right')
      .ticks(5)
      .title(config.yLabel)
      .dyTitle(-18);

    var colorLegend = sszvis.legend.ordinalColorScale()
      .scale(colorScale)
      .horizontalFloat(true);

    var tooltip = sszvis.annotation.tooltip()
      .renderInto(tooltipLayer)
      .header(function(d) {
        return aAcc(d) + '-jährige';
      })
      .body(function() {
        var rows = state.selectedAge.rows.map(function(r) {
          return [gAcc(r), sszvis.format.number(vAcc(r))];
        });
        return rows.concat([['Alter', state.selectedAge.age]]);
      })
      .orientation('left')
      .visible(function(d) {
        return state.selectedAge.age === aAcc(d) && gAcc(d) === 'Männer';
      });


    // Rendering

    chartLayer.selectGroup('xAxis')
      .attr('transform', sszvis.svgUtils.translateString(bounds.innerWidth / 2, bounds.innerHeight))
      .call(xAxis);

    chartLayer.selectGroup('yAxis')
      .attr('transform', sszvis.svgUtils.translateString(0, 0))
      .call(yAxis);

    chartLayer.selectGroup('populationPyramid')
      .datum(state.populations)
      .attr('transform', sszvis.svgUtils.translateString(bounds.innerWidth / 2, 0))
      .call(pyramid);

    chartLayer.selectAll('[data-tooltip-anchor]')
      .call(tooltip);

    chartLayer.selectGroup('colorLegend')
      .attr('transform', sszvis.svgUtils.translateString(0, bounds.innerHeight + 60))
      .call(colorLegend);


    // Interaction
    var interactionLayer = sszvis.behavior.move()
      .xScale(d3.scale.linear().range([0, bounds.innerWidth]))
      // using a continuous linear scale here ensures that the tooltip doesn't flicker on and off
      // if we were to use an ordinal scale, the tooltip would disappear while the mouse is in the spaces
      // between the bars, because the ordinal scale has no value there, while a linear scale does.
      .yScale(d3.scale.linear().domain(state.ageExtent).range([bounds.innerHeight, 0]))
      .on('move', actions.selectBar)
      .on('end', actions.deselectBar);

    chartLayer.selectGroup('interactionLayer')
      .call(interactionLayer);
  }


  /* Helper Functions
  ----------------------------------------------- */
  function isLeft(d) {
    return gAcc(d) === 'Frauen';
  }

}(d3, sszvis));
</script>
</body>
</html>
