<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Map</title>
</head>
<body style="margin:0;padding:0;">
<link href='../../sszvis.css' rel='stylesheet' />
<script src="../../vendor/d3/d3.min.js"></script>
<script src="../../vendor/topojson/topojson.js"></script>
<script src="../../sszvis.js"></script>

<div id="sszvis-chart"></div>

<script data-catalog-project-expose="script.js">
(function(d3, topojson, sszvis) {
  'use strict';

  /* Configuration
  ----------------------------------------------- */
  var TITLE = 'Diagrammtitel';
  var DESCRIPTION = 'Kurze Beschreibung des Inhalts dieses Diagramms';


  /* Shortcuts
  ----------------------------------------------- */
  var vAcc = sszvis.fn.prop('value');
  var yearAcc = sszvis.fn.prop('year');
  var geoIdAcc = sszvis.fn.prop('geoId');


  /* Application state
  ----------------------------------------------- */
  var state = {
    data: [],
    valueDomain: [0, 0],
    yearDomain: [new Date(), new Date()],
    lineData: [],
    currentYear: new Date(),
    currentMapData: [],
    highlightEntity: null,
    lineBaseColor: sszvis.color.gry()(0),
    lineHighlightColor: sszvis.color.qual12()(0)
  };


  /* State transitions
  ----------------------------------------------- */
  var actions = {
    prepareState: function(data) {
      state.data = data;
      state.valueDomain = [0, d3.max(state.data, vAcc)];
      state.yearDomain = d3.extent(state.data, yearAcc);

      // set up a cascade for sorting data into arrays based on which geoId they belong to
      var cascadedData = sszvis.cascade()
        .arrayBy(geoIdAcc)
        .sort(function(a, b) {
          return d3.ascending(yearAcc(a), yearAcc(b));
        })
        .apply(state.data);

      // transform the data into line objects, one for each line
      state.lineData = cascadedData.map(function(lineData) {
        return {
          geoId: geoIdAcc(sszvis.fn.first(lineData)),
          values: lineData
        };
      });

      // calculate a line which represents the average values in the dataset
      var averageLineValues = cascadedData.reduce(function(m, lineData) {
        lineData.forEach(function(datum, index) {
          if (!m[index]) {
            m[index] = {
              // isAverageValue is used by the handleRuler component to determine the correct tooltip
              isAverageValue: true,
              year: datum.year,
              value: 0
            };
          }
          m[index].value += Math.round(datum.value / cascadedData.length);
        });
        return m;
      }, []);
      state.averageLine = {
        // the average line can be identified because it has a null geoId
        geoId: null,
        values: averageLineValues
      };
      // add the average line to the lineData
      state.lineData.push(state.averageLine);

      actions.resetYear();
    },

    // this function is used to change either the active year or the active map entity.
    // it is called as the user moves the mouse over the line chart
    changeYearAndEntity: function(inputDate, inputValue) {
      // find the closest year to the mouse
      var closestYear = yearAcc(closestDatum(state.data, yearAcc, inputDate));
      if (state.currentYear !== closestYear) {
        state.currentMapData = state.data.filter(function(v) {
          return yearAcc(v).getFullYear() === closestYear.getFullYear();
        })
        .sort(function(a, b) {
          return d3.ascending(vAcc(a), vAcc(b)); // currentMapData has to be sorted so that d3.bisector will work on it.
        });
      }

      // within the current year's data values, find the one closest to the mouse position
      var closestEntry = inputValue === null ? null : closestDatum(state.currentMapData, vAcc, inputValue);

      // this is an optimization to ensure that the chart is only re-rendered when underlying state has changed
      if (state.currentYear !== closestYear || state.highlightEntity !== closestEntry) {
        state.currentYear = closestYear;
        state.highlightEntity = closestEntry;
        render(state);
      }
    },

    // resets the active year
    resetYear: function() {
      var mostRecentDate = d3.max(state.yearDomain);
      actions.changeYearAndEntity(mostRecentDate, null);
    },

    // called when moving over map entities with the mouse. Highlights certain entities
    changeMapEntity: function(d) {
      state.highlightEntity = d;
      render(state);
    },

    // reset the highlighted map entity
    resetMapEntity: function() {
      state.highlightEntity = null;
      render(state);
    }
  };


  /* Data initialization
  ----------------------------------------------- */
  d3.csv('data/CML_quartier_years.csv')
    .row(function(d) {
      return {
        geoId: sszvis.parse.number(d['QNr']),
        year: sszvis.parse.year(d['Jahr']),
        value: sszvis.parse.number(d['Anzahl']),
        name: d['Qname']
      };
    })
    .get(function(error, data) {
      if (error) {
        sszvis.loadError(error);
        return;
      }
      actions.prepareState(data);
    });


  /* Render
  ----------------------------------------------- */
  function render(state) {
    var mapHeight = 564, lineChartHeight = 162;
    var outerBounds = sszvis.bounds({ height: mapHeight + lineChartHeight, top: 0, right: 0, bottom: 0, left: 0 });
    // to match the design, the map should be 442 pixels across. This calculates padding required to achieve that.
    var padding = (sszvis.bounds.DEFAULT_WIDTH - 442) / 2;
    // bounds for the map section of the chart
    var mapBounds = sszvis.bounds({ height: mapHeight, top: 0, right: padding, bottom: 64, left: padding });
    // bounds for the line chart section
    var lineChartBounds = sszvis.bounds({ height: lineChartHeight, top: 24, right: 6, bottom: 20, left: 6 });


    // Scales

    // map fill scale
    var fillScale = sszvis.color.seqBlu()
      .domain(state.valueDomain);

    // line chart scales
    var xScale = d3.time.scale()
      .domain(state.yearDomain)
      .range([0, lineChartBounds.innerWidth]);

    var yScale = d3.scale.linear()
      .domain(state.valueDomain)
      .range([lineChartBounds.innerHeight, 0]);

    // Data

    // highlightData passed to the map is slightly different from the data passed to the line chart.
    // When no entity is highlighted, the map shows nothing special, but the line chart shows the average line.
    var mapHighlightData = state.highlightEntity ? [state.highlightEntity] : [];
    var lineHighlightData = state.highlightEntity ? [state.highlightEntity] : state.averageLine.values.filter(function(averageObj) {
      return yearAcc(averageObj).getFullYear() === state.currentYear.getFullYear();
    });


    // Layers

    var chart = sszvis.createSvgLayer('#sszvis-chart', outerBounds, {
      title: TITLE,
      description: DESCRIPTION
    });

    var map = chart.selectGroup('map')
      .attr('transform', sszvis.fn.translateString(mapBounds.padding.left, mapBounds.padding.top))
      .datum(state.currentMapData);

    var tooltipLayer = sszvis.createHtmlLayer('#sszvis-chart')
      .datum(mapHighlightData);

    var lineChart = chart.selectGroup('line')
      .attr('transform', sszvis.fn.translateString(lineChartBounds.padding.left, mapBounds.height + lineChartBounds.padding.top))
      .datum(state.lineData);

    var highlightLayer = chart.selectGroup('highlight')
      .attr('transform', sszvis.fn.translateString(lineChartBounds.padding.left, mapBounds.height + lineChartBounds.padding.top))
      .datum(lineHighlightData);


    // Components

    var mapMaker = sszvis.map()
      .type('zurich-statistischeQuartiere')
      .keyName('geoId')
      .highlight(mapHighlightData)
      .highlightStroke(function(d) {
        return d3.hsl(fillScale(vAcc(d))).darker(0.7);
      })
      .width(mapBounds.innerWidth)
      .height(mapBounds.innerHeight)
      .fill(sszvis.fn.compose(fillScale, vAcc))
      .on('over', actions.changeMapEntity)
      .on('out', actions.resetMapEntity);

    var lineMaker = sszvis.component.line()
      // passing a key function here is important, because the DOM order of the lines is changed
      // by highlighting a line. When a line is highlighted, it is sorted to the front of other lines.
      // This sorting is performed later in the code.
      .key(sszvis.fn.prop('geoId'))
      .valuesAccessor(sszvis.fn.prop('values'))
      .x(sszvis.fn.compose(xScale, yearAcc))
      .y(sszvis.fn.compose(yScale, vAcc))
      .stroke(function(lineData) {
        // this function determines whether the line is the highlighted line or not
        var isBlue;
        if (!state.highlightEntity) {
          isBlue = lineData.geoId === null; // if so, this is the average line
        } else {
          isBlue = state.highlightEntity.geoId === lineData.geoId;
        }
        return isBlue ? state.lineHighlightColor : state.lineBaseColor;
      });

    var xTickValues = xScale
      .ticks(4)
      .concat(state.currentYear);

    var lineXAxis = sszvis.axis.x.time()
      .scale(xScale)
      .orient('bottom')
      .tickValues(xTickValues)
      .highlightTick(tickIsSelected);

    var lineYAxis = sszvis.axis.y()
      .scale(yScale)
      .orient('right')
      .contour('rect');

    var rulerLabel = sszvis.component.modularText.svg()
      .bold(sszvis.fn.compose(sszvis.format.number, vAcc))
      .plain(function(d) {
        return d.isAverageValue ? 'Einwohner (Durchschnitt)' : 'Einwohner';
      });

    // The bar which marks the current year and shows the value of the highlighted entity
    var handleRuler = sszvis.component.handleRuler()
      .x(xScale(state.currentYear))
      .y(sszvis.fn.compose(yScale, vAcc))
      .top(0)
      .bottom(lineChartBounds.innerHeight)
      .flip(function(d) {
        return xScale(yearAcc(d)) >= lineChartBounds.innerWidth / 2;
      })
      .color(sszvis.color.qual12())
      .label(rulerLabel);

    // see the comment by the tooltip in docs/map/kreis.html for more information
    // about accesing data properties of map entities.
    var tooltipHeader = sszvis.component.modularText.html()
      .bold(function(d) {
        return sszvis.format.number(vAcc(d.datum));
      })
      .plain(' Einwohner');

    var tooltip = sszvis.component.tooltip()
      .renderInto(tooltipLayer)
      .header(tooltipHeader)
      .body(function(d) {
        return d.datum.name;
      })
      .visible(function(d) {
        return state.highlightEntity === d.datum;
      });

    var legend = sszvis.legend.linearColorScale()
      .scale(fillScale)
      .width(mapBounds.width / 2)
      .labelFormat(sszvis.format.number);

    // Rendering

    map.call(mapMaker);

    map.selectAll('[data-tooltip-anchor]')
      .call(tooltip);

    lineChart.call(lineMaker);

    // this sorts the highlighted line to the front of all lines
    lineChart.selectAll('.sszvis-line').sort(function(a, b) {
      var highlightId = state.highlightEntity ? state.highlightEntity.geoId : null;
      return a.geoId === highlightId ? 1 : b.geoId === highlightId ? -1 : 0;
    });

    lineChart.selectGroup('xAxis')
      .attr('transform', 'translate(0, ' + (lineChartBounds.innerHeight) + ')')
      .call(lineXAxis);

    lineChart.selectGroup('yAxis')
      .call(lineYAxis);

    highlightLayer.selectGroup('handleRuler')
      .call(handleRuler);

    // for Zurich maps, the color legend should be positioned 60 pixels below the bottom of the map
    chart.selectGroup('legend')
      .attr('transform', sszvis.fn.translateString(mapBounds.width / 4, mapBounds.innerHeight + 20))
      .call(legend);


    // Interaction

    // add the hover behavior for the chart, including top padding so that the area around the slide bar handle
    // is responsive to mouse events.
    var hoverBehavior = sszvis.behavior.move()
      .xScale(xScale)
      .yScale(yScale)
      .padding({ top: 30 })
      .on('move', actions.changeYearAndEntity);

    highlightLayer.selectGroup('interaction')
      .call(hoverBehavior);
  }


  /* Helper functions
  ----------------------------------------------- */
  // given a dataset, an accessor, and a value, find the closest datum in the dataset to that value
  function closestDatum(data, accessor, value) {
    var i = d3.bisector(accessor).left(data, value, 1);
    var d0 = data[i - 1];
    var d1 = data[i] || d0;
    return value - accessor(d0) > accessor(d1) - value ? d1 : d0;
  }

  function tickIsSelected(d) {
    return sszvis.fn.stringEqual(state.currentYear, d);
  }


}(d3, topojson, sszvis));
</script>
</body>
</html>
