{"version":3,"file":"breakpoint.js","sources":["../src/breakpoint.js"],"sourcesContent":["/**\n * Responsive design breakpoints for sszvis\n *\n * @module sszvis/breakpoint\n *\n * Provides breakpoint-related functions, including those which build special\n * breakpoint objects that can be used to test against screen measurements to see\n * if the breakpoint matches, and this module also includes the default breakpoint\n * sizes for SSZVIS. The breakpoints are inclusive upper limits, i.e. when testing a\n * breakpoint against a given set of measurements, if the breakpoint value is greater than\n * or equal to all measurements, the breakpoint will match. In code where the user should\n * supply breakpoints, the user is responsible for specifying the testing order of the breakpoints\n * provided. The breakpoints are then tested in order, and the first one which matches the measurements\n * is chosen. The user should, where possible, specify breakpoints in increasing order of size.\n * Since there are multiple dimensions on which 'size' can be defined, we do not specify our own\n * algorithm for sorting user-defined breakpoints. We rely on the judgment of the user to do that.\n *\n * @property {Function} createSpec\n * @property {Function} defaultSpec\n * @property {Function} findByName\n * @property {Function} find\n * @property {Function} match\n * @property {Function} test\n *\n * @property {Function} palm Breakpoint for plam-sized devices (phones)\n * @property {Function} lap  Breakpoint for lap-sized devices (tablets, small notebooks)\n *\n * @type Measurement {\n *   width: number,\n *   screenHeight: number\n * }\n *\n * @type Breakpoint {\n *   name: string,\n *   measurement: Measurement\n * }\n */\n\nimport * as fn from \"./fn.js\";\n\n/**\n * breakpoint.find\n *\n * Returns the first matching breakpoint for a given measurement\n *\n * @param {Array<Breakpoint>} breakpoints A breakpoint spec\n * @param {Measurement} partialMeasurement A partial measurement to match to the spec\n * @returns {Breakpoint}\n */\nexport function breakpointFind(breakpoints, partialMeasurement) {\n  const measurement = parseMeasurement(partialMeasurement);\n  return fn.find((bp) => breakpointTest(bp, measurement), breakpoints);\n}\n\n/**\n * breakpoint.findByName\n *\n * Returns the breakpoint with the given name. If there is no such breakpoint,\n * undefined is returned\n *\n * @param {Array<Breakpoint>} breakpoints A breakpoint spec\n * @param {string} name A breakpoint name\n * @returns {Breakpoint?} If no breakpoint matches, undefined is returned. If a\n *          breakpoint for the given name exists, that breakpoint is returned\n */\nexport function breakpointFindByName(breakpoints, name) {\n  const eqName = function (bp) {\n    return bp.name === name;\n  };\n  return fn.find(eqName, breakpoints);\n}\n\n/**\n * breakpoint.test\n *\n * Returns true if the given measurement fits within the breakpoint.\n *\n * @param {Breakpoint} breakpoint A single breakpoint\n * @param {Measurement} partialMeasurement A partial measurement to match to the breakpoint\n * @returns {boolean}\n */\nexport function breakpointTest(breakpoint, partialMeasurement) {\n  const bpm = breakpoint.measurement;\n  const measurement = parseMeasurement(partialMeasurement);\n  return measurement.width <= bpm.width && measurement.screenHeight <= bpm.screenHeight;\n}\n\n/**\n * breakpoint.match\n *\n * Returns an array of breakpoints the given measurement fits into. Use this in situations\n * where you need to match a sparse list of breakpoints.\n *\n * @param {Array<Breakpoint>} breakpoints A breakpoint spec\n * @param {Measurement} partialMeasurement A partial measurement to match to the spec\n * @returns {Array<Breakpoint>}\n */\nexport function breakpointMatch(breakpoints, partialMeasurement) {\n  const measurement = parseMeasurement(partialMeasurement);\n  return breakpoints.filter((bp) => breakpointTest(bp, measurement));\n}\n\n/**\n * breakpoint.createSpec\n *\n * Parses an array of partial breakpoints into a valid breakpoint spec.\n *\n * @param {Array<{name: string, width?: number, screenHeight?: number}>} spec An array\n *        of breakpoint definitions. All breakpoints are parsed into a full representation,\n *        so it's possible to only provide partial breakpoint definitions.\n * @returns {Array<Breakpoint>}\n */\nexport function breakpointCreateSpec(spec) {\n  return [...spec.map(parseBreakpoint), parseBreakpoint({ name: \"_\" })];\n}\n\n/**\n * breakpoint.defaultSpec\n *\n * @returns {Array<{name: string, width: number, screenHeight: number}>} The SSZVIS\n *          default breakpoint spec.\n */\nexport const breakpointDefaultSpec = (function () {\n  const DEFAULT_SPEC = breakpointCreateSpec([\n    { name: \"palm\", width: 540 },\n    { name: \"lap\", width: 749 },\n  ]);\n  return function () {\n    return DEFAULT_SPEC;\n  };\n})();\n\n// Default tests\nexport const breakpointPalm = makeTest(\"palm\");\nexport const breakpointLap = makeTest(\"lap\");\n\n// Helpers\n\n/**\n * Measurement\n *\n * A measurement is defined as an object with width and screenHeight props.\n * It is used throughout the breakpoint calculations.\n *\n * For parsing, a partial measurement can be supplied. If a property is\n * not defined, it is initialized to Infinity, which matches all breakpoints.\n *\n * @example\n *   const Measurement = {\n *     width: number,\n *     screenHeight: number\n *   }\n *\n * @param {{width?: number, screenHeight?: number}} partialMeasurement\n * @returns Measurement\n */\nfunction parseMeasurement(partialMeasurement) {\n  const widthOrInf = fn.propOr(\"width\", Infinity);\n  const screenHeightOrInf = fn.propOr(\"screenHeight\", Infinity);\n  return {\n    width: widthOrInf(partialMeasurement),\n    screenHeight: screenHeightOrInf(partialMeasurement),\n  };\n}\n\n/**\n * Breakpoint\n *\n * A breakpoint is defined as an object with name and measurement props.\n * It is used throughout the breakpoint calculations.\n *\n * For parsing, a partial breakpoint can be supplied where measurements\n * can be directly supplied on the top object.\n *\n * @example\n *   const PartialBreakpoint = {\n *     name: string,\n *     width?: number,\n *     screenHeight?: number\n *   }\n *\n *   const Breakpoint = {\n *     name: string,\n *     measurement: Measurement\n *   }\n *\n * @param {{name: string, width?: number, screenHeight?: number, measurement?: Measurement}} bp\n * @returns Breakpoint\n */\nfunction parseBreakpoint(bp) {\n  const measurement = fn.defined(bp.measurement)\n    ? parseMeasurement(bp.measurement)\n    : parseMeasurement({ width: bp.width, screenHeight: bp.screenHeight });\n  return {\n    name: bp.name,\n    measurement,\n  };\n}\n\n/**\n * Create a partially applied test function\n */\nfunction makeTest(name) {\n  return function (measurement) {\n    return breakpointTest(breakpointFindByName(breakpointDefaultSpec(), name), measurement);\n  };\n}\n"],"names":["breakpointFind","breakpoints","partialMeasurement","measurement","parseMeasurement","fn","bp","breakpointTest","breakpointFindByName","name","eqName","breakpoint","bpm","width","screenHeight","breakpointMatch","filter","breakpointCreateSpec","spec","map","parseBreakpoint","breakpointDefaultSpec","DEFAULT_SPEC","breakpointPalm","makeTest","breakpointLap","widthOrInf","Infinity","screenHeightOrInf"],"mappings":"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"}